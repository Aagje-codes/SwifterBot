
  Swift is a new programming language for iOS and OS X apps that builds on the best of C and Objective-C, without the constraints of C compatibility. Swift adopts safe programming patterns and adds modern features to make programming easier, more flexible, and more fun. Swift's clean slate, backed by the mature and much-loved Cocoa and Cocoa Touch frameworks, is an opportunity to reimagine how software development works.

  Swift has been years in the making. Apple laid the foundation for Swift by advancing our existing compiler, debugger, and framework infrastructure. We simplified memory management with Automatic Reference Counting (ARC). Our framework stack, built on the solid base of Foundation and Cocoa, has been modernized and standardized throughout. Objective-C itself has evolved to support blocks, collection literals, and modules, enabling framework adoption of modern language technologies without disruption. Thanks to this groundwork, we can now introduce a new language for the future of Apple software development.

  Swift feels familiar to Objective-C developers. It adopts the readability of Objective-C's named parameters and the power of Objective-C's dynamic object model. It provides seamless access to existing Cocoa frameworks and mix-and-match interoperability with Objective-C code. Building from this common ground, Swift introduces many new features and unifies the procedural and object-oriented portions of the language.

  Swift is friendly to new programmers. It is the first industrial-quality systems programming language that is as expressive and enjoyable as a scripting language. It supports playgrounds, an innovative feature that allows programmers to experiment with Swift code and see the results immediately, without the overhead of building and running an app.

  Swift combines the best in modern language thinking with wisdom from the wider Apple engineering culture. The compiler is optimized for performance, and the language is optimized for development, without compromising on either. It's designed to scale from “hello, world” to an entire operating system. All this makes Swift a sound future investment for developers and for Apple.

  Swift is a fantastic way to write iOS and OS X apps, and will continue to evolve with new features and capabilities. Our goals for Swift are ambitious. We can't wait to see what you create with it.
Copyright � 2015 Apple Inc. All rights reserved. 
  Tradition suggests that the first program in a new language should print the words “Hello, world!” on the screen. In Swift, this can be done in a single line:

  If you have written code in C or Objective-C, this syntax looks familiar to you—in Swift, this line of code is a complete program. You don't need to import a separate library for functionality like input/output or string handling. Code written at global scope is used as the entry point for the program, so you don't need a  function. You also don't need to write semicolons at the end of every statement.

  This tour gives you enough information to start writing code in Swift by showing you how to accomplish a variety of programming tasks. Don't worry if you don't understand something—everything introduced in this tour is explained in detail in the rest of this book.

        For the best experience, open this chapter as a playground in Xcode.
        Playgrounds allow you to edit the code listings and see the result 
        immediately.
     to make a variable. The value of a constant doesn't need to be known at compile time, but you must assign it a value exactly once. This means you can use constants to name a value that you determine once but use in many places.

  A constant or variable must have the same type as the value you want to assign to it. However, you don't always have to write the type explicitly. Providing a value when you create a constant or variable lets the compiler infer its type. In the example above, the compiler infers that  is an integer because its initial value is an integer.

  If the initial value doesn't provide enough information (or if there is no initial value), specify the type by writing it after the variable, separated by a colon.
.
    	
  Values are never implicitly converted to another type. If you need to convert a value to a different type, explicitly make an instance of the desired type.
 from the last line. What error do you get?
    	) before the parentheses. For example:
 to include a floating-point calculation in a string and to include someone's name in a greeting.
    	), and access their elements by writing the index or key in brackets.

  To create an empty array or dictionary, use the initializer syntax.
—for example, when you set a new value for a variable or pass an argument to a function.
 to make loops. Parentheses around the condition or loop variable are optional. Braces around the body are required.
 is an error, not an implicit comparison to zero.
 together to work with values that might be missing. These values are represented as optionals. An optional value either contains a value or contains  to indicate that a value is missing. Write a question mark () after the type of a value to mark the value as optional.
. What greeting do you get? Add an .
    	 and the code in braces is skipped. Otherwise, the optional value is unwrapped and assigned to the constant after , which makes the unwrapped value available inside the block of code.

  Switches support any kind of data and a wide variety of comparison operations—they aren't limited to integers and tests for equality.
Try removing the default case. What error do you get?
    	 can be used in a pattern to assign the value that matched that part of a pattern to a constant.

  After executing the code inside the switch case that matched, the program exits from the switch statement. Execution doesn't continue to the next case, so there is no need to explicitly break out of the switch at the end of each case's code.
 to iterate over items in a dictionary by providing a pair of names to use for each key-value pair. Dictionaries are an unordered collection, so their keys and values are iterated over in an arbitrary order.
Add another variable to keep track of which kind of number was the largest, as well as what that largest number was.
    	 to repeat a block of code until a condition changes. The condition of a loop can be at the end instead, ensuring that the loop is run at least once.
 to make a range of indexes or by writing an explicit initialization, condition, and increment. These two loops do the same thing:
 to make a range that includes both values.
 to declare a function. Call a function by following its name with a list of arguments in parentheses. Use  to separate the parameter names and types from the function's return type.
 parameter. Add a parameter to include today's lunch special in the greeting.
    	
  Use a tuple to make a compound value—for example, to return multiple values from a function. The elements of a tuple can be referred to either by name or by number.

  Functions can also take a variable number of arguments, collecting them into an array.
Write a function that calculates the average of its arguments.
    	
  Functions can be nested. Nested functions have access to variables that were declared in the outer function. You can use nested functions to organize the code in a function that is long or complex.

  Functions are a first-class type. This means that a function can return another function as its value.

  A function can take another function as one of its arguments.

  Functions are actually a special case of closures: blocks of code that can be called later. The code in a closure has access to things like variables and functions that were available in the scope where the closure was created, even if the closure is in a different scope when it is executed—you saw an example of this already with nested functions. You can write a closure without a name by surrounding code with braces (). Use  to separate the arguments and return type from the body.
Rewrite the closure to return zero for all odd numbers.
    	
  You have several options for writing closures more concisely. When a closure's type is already known, such as the callback for a delegate, you can omit the type of its parameters, its return type, or both. Single statement closures implicitly return the value of their only statement.

  You can refer to parameters by number instead of by name—this approach is especially useful in very short closures. A closure passed as the last argument to a function can appear immediately after the parentheses.
 followed by the class's name to create a class. A property declaration in a class is written the same way as a constant or variable declaration, except that it is in the context of a class. Likewise, method and function declarations are written the same way.
, and add another method that takes an argument.
    	
  Create an instance of a class by putting parentheses after the class name. Use dot syntax to access the properties and methods of the instance.
 class is missing something important: an initializer to set up the class when an instance is created. Use  to create one.
 argument to the initializer. The arguments to the initializer are passed like a function call when you create an instance of the class. Every property needs a value assigned—either in its declaration (as with ).
 to create a deinitializer if you need to perform some cleanup before the object is deallocated.

  Subclasses include their superclass name after their class name, separated by a colon. There is no requirement for classes to subclass any standard root class, so you can include or omit a superclass as needed.
, is detected by the compiler as an error. The compiler also detects methods with  that don't actually override any method in the superclass.
 that takes a radius and a name as arguments to its initializer. Implement an  class.
    	
  In addition to simple properties that are stored, properties can have a getter and a setter.
. You can provide an explicit name in parentheses after .

  Setting the value of properties that the subclass declares.

  Calling the superclass's initializer.

  Changing the value of properties defined by the superclass. Any additional setup work that uses methods, getters, or setters can also be done at this point.
. For example, the class below ensures that the side length of its triangle is always the same as the side length of its square.

  Methods on classes have one important difference from functions. Parameter names in functions are used only within the function, but parameters names in methods are also used when you call the method (except for the first parameter). By default, a method has the same name for its parameters when you call it and within the method itself. You can specify a second name, which is used inside the method.
 before operations like methods, properties, and subscripting. If the value before the . Otherwise, the optional value is unwrapped, and everything after the  acts on the unwrapped value. In both cases, the value of the whole expression is an optional value.
 to create an enumeration. Like classes and all other named types, enumerations can have methods associated with them.
 values by comparing their raw values.
    	, so you only have to specify the first raw value. The rest of the raw values are assigned in order. You can also use strings or floating-point numbers as the raw type of an enumeration. Use the  property to access the raw value of an enumeration member.
 initializer to make an instance of an enumeration from a raw value.

  The member values of an enumeration are actual values, not just another way of writing their raw values. In fact, in cases where there isn't a meaningful raw value, you don't have to provide one.
 that returns “black” for spades and clubs, and returns “red” for hearts and diamonds.
    	 is referred to by its full name because the constant doesn't have an explicit type specified. Inside the switch, the enumeration member is referred to by the abbreviated form  is already known to be a suit. You can use the abbreviated form anytime the value's type is already known.
 to create a structure. Structures support many of the same behaviors as classes, including methods and initializers. One of the most important differences between structures and classes is that structures are always copied when they are passed around in your code, but classes are passed by reference.
 that creates a full deck of cards, with one card of each combination of rank and suit.
    	
  An instance of an enumeration member can have values associated with the instance. Instances of the same enumeration member can have different values associated with them. You provide the associated values when you create the instance. Associated values and raw values are different: The raw value of an enumeration member is the same for all of its instances, and you provide the raw value when you define the enumeration.

  For example, consider the case of requesting the sunrise and sunset time from a server. The server either responds with the information or it responds with some error information.
 and to the switch.
    	 value as part of matching the value against the switch cases.
 to declare a protocol.

  Classes, enumerations, and structs can all adopt protocols.
Write an enumeration that conforms to this protocol.
    	 to mark a method that modifies the structure. The declaration of  doesn't need any of its methods marked as mutating because methods on a class can always modify the class.
 to add functionality to an existing type, such as new methods and computed properties. You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.
 property.
    	
  You can use a protocol name just like any other named type—for example, to create a collection of objects that have different types but that all conform to a single protocol. When you work with values whose type is a protocol type, methods outside the protocol definition are not available.
. This means that you can't accidentally access methods or properties that the class implements in addition to its protocol conformance.

  Write a name inside angle brackets to make a generic function or type.

  You can make generic forms of functions and methods, as well as classes, enumerations, and structures.
 after the type name to specify a list of requirements—for example, to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.
 function to make a function that returns an array of the elements that any two sequences have in common.
    	 and simply write the protocol or class name after a colon. Writing .
Copyright � 2015 Apple Inc. All rights reserved. 
  Swift is a new programming language for iOS and OS X app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C.
 for textual data. Swift also provides powerful versions of the two primary collection types, .

  Like C, Swift uses variables to store and refer to values by an identifying name. Swift also makes extensive use of variables whose values cannot be changed. These are known as constants, and are much more powerful than constants in C. Constants are used throughout Swift to make code safer and clearer in intent when you work with values that do not need to change.

  In addition to familiar types, Swift introduces advanced types not found in Objective-C, such as tuples. Tuples enable you to create and pass around groupings of values. You can use a tuple to return multiple values from a function as a single compound value.

  Swift also introduces optional types, which handle the absence of a value. Optionals say either “there  a value at all”. Optionals are similar to using  with pointers in Objective-C, but they work for any type, not just classes. Optionals are safer and more expressive than  pointers in Objective-C and are at the heart of many of Swift's most powerful features.
 language. Swift helps you to be clear about the types of values your code can work with. If part of your code expects a  by mistake. This restriction enables you to catch and fix errors as early as possible in the development process.
). The value of a  can be set to a different value in the future.

  Constants and variables must be declared before they are used. You declare constants with the  keyword. Here's an example of how constants and variables can be used to track the number of login attempts a user has made:
. Then, declare a new variable called .”

  In this example, the maximum number of allowed login attempts is declared as a constant, because the maximum value never changes. The current login attempt counter is declared as a variable, because this value must be incremented after each failed login attempt.
 keyword. Use variables only for storing values that need to be able to change.
    	 when you declare a constant or variable, to be clear about the kind of values the constant or variable can store. Write a type annotation by placing a colon after the constant or variable name, followed by a space, followed by the name of the type to use.
.”
 value.” Think of it as meaning “the type of thing” (or “the kind of thing”) that can be stored.
It is rare that you need to write type annotations in practice. If you provide an initial value for a constant or variable at the point that it is defined, Swift can almost always infer the type to be used for that constant or variable, as described in . In the  variable is specified with a type annotation rather than being inferred from an initial value.
    	
  Constant and variable names cannot contain whitespace characters, mathematical symbols, arrows, private-use (or invalid) Unicode code points, or line- and box-drawing characters. Nor can they begin with a number, although numbers may be included elsewhere within the name.

  Once you've declared a constant or variable of a certain type, you can't redeclare it again with the same name, or change it to store values of a different type. Nor can you change a constant into a variable or a variable into a constant.
) when using it as a name. However, avoid using keywords as names unless you have absolutely no choice.
    	
  You can change the value of an existing variable to another value of a compatible type. In this example, the value of 
  Unlike a variable, the value of a constant cannot be changed once it is set. Attempting to do so is reported as an error when your code is compiled:
 is a global function that prints a value, followed by a line break, to an appropriate output. In Xcode, for example,  prints its output in Xcode's “console” pane. (A second function, , performs the same task without appending a line break to the end of the value to be printed.)
 function. These messages can include the current values of constants and variables.
 to include the name of a constant or variable as a placeholder in a longer string, and to prompt Swift to replace it with the current value of that constant or variable. Wrap the name in parentheses and escape it with a backslash before the opening parenthesis:
.
    	
  Use comments to include non-executable text in your code, as a note or reminder to yourself. Comments are ignored by the Swift compiler when your code is compiled.

  Comments in Swift are very similar to comments in C. Single-line comments begin with two forward-slashes (
  Unlike multiline comments in C, multiline comments in Swift can be nested inside other multiline comments. You write nested comments by starting a multiline comment block and then starting a second multiline comment within the first block. The second block is then closed, followed by the first block:

  Nested multiline comments enable you to comment out large blocks of code quickly and easily, even if the code already contains multiline comments.
) after each statement in your code, although you can do so if you wish. Semicolons . Integers are either  (positive or zero).

  Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms. These integers follow a naming convention similar to C, in that an 8-bit unsigned integer is of type . Like all types in Swift, these integer types have capitalized names.
 in the example above) and can therefore be used in expressions alongside other values of the same type.

  In most cases, you don't need to pick a specific size of integer to use in your code. Swift provides an additional integer type, .
.
 for integer values in your code. This aids code consistency and interoperability. Even on 32-bit platforms, , and is large enough for many integer ranges.
.
.
 only when you specifically need an unsigned integer type with the same size as the platform's native word size. If this is not the case,  is preferred, even when the values to be stored are known to be non-negative. A consistent use of .
    	.
. Swift provides two signed floating-point number types:
 represents a 64-bit floating-point number.
 represents a 32-bit floating-point number.
 can be as little as 6 decimal digits. The appropriate floating-point type to use depends on the nature and range of values you need to work with in your code. In situations where either type would be appropriate,  is preferred.
    	 language. A type safe language encourages you to be clear about the types of values your code can work with. If part of your code expects a  by mistake.
 when compiling your code and flags any mismatched types as errors. This enables you to catch and fix errors as early as possible in the development process.

  Type-checking helps you avoid errors when you're working with different types of values. However, this doesn't mean that you have to specify the type of every constant and variable that you declare. If you don't specify the type of value you need, Swift uses  to work out the appropriate type. Type inference enables a compiler to deduce the type of a particular expression automatically when it compiles your code, simply by examining the values you provide.

  Because of type inference, Swift requires far fewer type declarations than languages such as C or Objective-C. Constants and variables are still explicitly typed, but much of the work of specifying their type is done for you.

  Type inference is particularly useful when you declare a constant or variable with an initial value. This is often done by assigning a ) to the constant or variable at the point that you declare it. (A literal value is a value that appears directly in your source code, such as  in the examples below.)
) when inferring the type of floating-point numbers.
 is inferred from the presence of a floating-point literal as part of the addition.
 prefix). They must always have a number (or hexadecimal number) on both sides of the decimal point. They can also have an optional  for hexadecimal floats.
 means 1.25 x 10.
 means 1.25 x 10.
.
.

  Numeric literals can contain extra formatting to make them easier to read. Both integers and floats can be padded with extra zeroes and can contain underscores to help with readability. Neither type of formatting affects the underlying value of the literal:
 type for all general-purpose integer constants and variables in your code, even if they are known to be non-negative. Using the default integer type in everyday situations means that integer constants and variables are immediately interoperable in your code and will match the inferred type for integer literal values.

  Use other integer types only when they are specifically needed for the task at hand, because of explicitly-sized data from an external source, or for performance, memory usage, or other necessary optimization. Using explicitly-sized types in these situations helps to catch any accidental value overflows and implicitly documents the nature of the data being used.

  The range of numbers that can be stored in an integer constant or variable is different for each numeric type. An . A number that will not fit into a constant or variable of a sized integer type is reported as an error when your code is compiled:

  Because each numeric type can store a different range of values, you must opt in to numeric type conversion on a case-by-case basis. This opt-in approach prevents hidden conversion errors and helps make type conversion intentions explicit in your code.

  To convert one specific number type to another, you initialize a new number of the desired type with the existing value. In the example below, the constant . They cannot be added together directly, because they are not of the same type. Instead, this example calls , the addition is allowed. The output constant ( values.
 is the default way to call the initializer of a Swift type and pass in an initial value. Behind the scenes, . You can't pass in  provides an initializer. Extending existing types to provide initializers that accept new types (including your own type definitions) is covered in .
, so that both sides of the addition are of the same type. Without this conversion in place, the addition would not be allowed.

  Floating-point to integer conversion must also be made explicit. An integer type can be initialized with a 
  Floating-point values are always truncated when used to initialize a new integer value in this way. This means that .
The rules for combining numeric constants and variables are different from the rules for numeric literals. The literal value , because number literals do not have an explicit type in and of themselves. Their type is inferred only at the point that they are evaluated by the compiler.
    	 define an alternative name for an existing type. You define type aliases with the  keyword.
. Because it is an alias, the call to  variable.
. Boolean values are referred to as , because they can only ever be true or false. Swift provides two Boolean constant values,  from the fact that they were initialized with Boolean literal values. As with  as soon as you create them. Type inference helps make Swift code more concise and readable when it initializes constants or variables with other values whose type is already known.
.
. The following example reports a compile-time error:
, and so this second example passes the type-check. Comparisons like .

  As with other examples of type safety in Swift, this approach avoids accidental errors and ensures that the intention of a particular section of code is always clear.
 group multiple values into a single compound value. The values within a tuple can be of any type and do not have to be of the same type as each other.
. An HTTP status code is a special value returned by a web server whenever you request a web page. A status code of  is returned if you request a webpage that doesn't exist.
 to give the HTTP status code two separate values: a number and a human-readable description. It can be described as “a tuple of type ”.

  You can create tuples from any permutation of types, and they can contain as many different types as you like. There's nothing stopping you from having a tuple of type , or indeed any other permutation you require.

  Tuples are particularly useful as the return values of functions. A function that tries to retrieve a web page might return the  tuple type to describe the success or failure of the page retrieval. By returning a tuple with two distinct values, each of a different type, the function provides more useful information about its outcome than if it could only return a single value of a single type. For more information, see .
Tuples are useful for temporary groups of related values. They are not suited to the creation of complex data structures. If your data structure is likely to persist beyond a temporary scope, model it as a class or structure, rather than as a tuple. For more information, see .
    	 in situations where a value may be absent. An optional says:
The concept of optionals doesn't exist in C or Objective-C. The nearest thing in Objective-C is the ability to return  meaning “the absence of a valid object.” However, this only works for objects—it doesn't work for structures, basic C types, or enumeration values. For these types, Objective-C methods typically return a special value (such as ) to indicate the absence of a value. This approach assumes that the method's caller knows there is a special value to test against and remembers to check for it. Swift's optionals let you indicate the absence of a value for , without the need for special constants.
    	
  Here's an example of how optionals can be used to cope with the absence of a value. Swift's  value. However, not every string can be converted into an integer. The string  does not have an obvious numeric value to convert to.
. An optional . The question mark indicates that the value it contains is optional, meaning that it might contain . (It can't contain anything else, such as a  value. It's either an , or it's nothing at all.)
 cannot be used with nonoptional constants and variables. If a constant or variable in your code needs to work with the absence of a value under certain conditions, always declare it as an optional value of the appropriate type.
    	 in Objective-C. In Objective-C,  is a pointer to a nonexistent object. In Swift,  is not a pointer—it is the absence of a value of a certain type. Optionals of , not just object types.
    	. You perform this comparison with the “equal to” operator ().
) to the end of the optional's name. The exclamation mark effectively says, “I know that this optional definitely has a value; please use it.” This is known as .
 to access a non-existent optional value triggers a runtime error. Always make sure that an optional contains a non- to force-unwrap its value.
    	 to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable. Optional binding can be used with  statements to check for a value inside an optional, and to extract that value into a constant or variable, as part of a single action. .
 to the value contained in the optional.”
 statement. It has already been initialized with the value contained  suffix to access its value. In this example,  is simply used to print the result of the conversion.

  You can use both constants and variables with optional binding. If you wanted to manipulate the value of  instead, and the value contained within the optional would be made available as a variable rather than a constant.
 statement as a comma-separated list of assignment expressions.

  As described above, optionals indicate that a constant or variable is allowed to have “no value”. Optionals can be checked with an  statement to see if a value exists, and can be conditionally unwrapped with optional binding to access the optional's value if it does exist.
 have a value, after that value is first set. In these cases, it is useful to remove the need to check and unwrap the optional's value every time it is accessed, because it can be safely assumed to have a value all of the time.
. You write an implicitly unwrapped optional by placing an exclamation mark () after the type that you want to make optional.

  Implicitly unwrapped optionals are useful when an optional's value is confirmed to exist immediately after the optional is first defined and can definitely be assumed to exist at every point thereafter. The primary use of implicitly unwrapped optionals in Swift is during class initialization, as described in .

  An implicitly unwrapped optional is a normal optional behind the scenes, but can also be used like a nonoptional value, without the need to unwrap the optional value each time it is accessed. The following example shows the difference in behavior between an optional string and an implicitly unwrapped optional string when accessing their wrapped value as an explicit 
  You can think of an implicitly unwrapped optional as giving permission for the optional to be unwrapped automatically whenever it is used. Rather than placing an exclamation mark after the optional's name each time you use it, you place an exclamation mark after the optional's type when you declare it.
If you try to access an implicitly unwrapped optional when it does not contain a value, you will trigger a runtime error. The result is exactly the same as if you place an exclamation mark after a normal optional that does not contain a value.
    	 at a later point. Always use a normal optional type if you need to check for a  value during the lifetime of a variable.
    	
  Optionals enable you to check for values that may or may not exist, and to write code that copes gracefully with the absence of a value. In some cases, however, it is simply not possible for your code to continue execution if a value does not exist, or if a provided value does not satisfy certain conditions. In these situations, you can trigger an  in your code to end code execution and to provide an opportunity to debug the cause of the absent or invalid value.
. Literally put, an assertion “asserts” that a condition is true. You use an assertion to make sure that an essential condition is satisfied before executing any further code. If the condition evaluates to , code execution ends, and your app is terminated.

  If your code triggers an assertion while running in a debug environment, such as when you build and run an app in Xcode, you can see exactly where the invalid state occurred and query the state of your app at the time that the assertion was triggered. An assertion also lets you provide a suitable debug message as to the nature of the assert.
 function. You pass the  is non-negative. If the value of , and the assertion is triggered, terminating the application.
 be true in order for your code to continue execution. Suitable scenarios for an assertion check include:

  An integer subscript index is passed to a custom subscript implementation, but the subscript index value could be too low or too high.

  A value is passed to a function, but an invalid value means that the function cannot fulfill its task.
 value is essential for subsequent code to execute successfully.
.
Assertions cause your app to terminate and are not a substitute for designing your code in such a way that invalid conditions are unlikely to arise. Nonetheless, in situations where invalid conditions are possible, an assertion is an effective way to ensure that such conditions are highlighted and noticed during development, before your app is published.
    	Copyright � 2015 Apple Inc. All rights reserved.  is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (). More complex examples include the logical AND operator .

  Swift supports most standard C operators and improves several capabilities to eliminate common coding errors. The assignment operator () is intended. Arithmetic operators ( and so forth) detect and disallow value overflow, to avoid unexpected results when working with numbers that become larger or smaller than the allowed value range of the type that stores them. You can opt in to value overflow behavior by using Swift's overflow operators, as described in .
) calculations on floating-point numbers. Swift also provides two range operators () not found in C, as a shortcut for expressing a range of values.

  This chapter describes the common operators in Swift.  covers Swift's advanced operators, and describes how to define your own custom operators and implement the standard operators for your own custom types.
). Unary ).
 because they appear in between their two targets.
 operators operate on three targets. Like C, Swift has only one ternary operator, the ternary conditional operator ().
. In the expression .

  Unlike the assignment operator in C and Objective-C, the assignment operator in Swift does not itself return a value. The following statement is not valid:
) is actually intended. By making  invalid, Swift helps you to avoid these kinds of errors in your code.

  Unlike the arithmetic operators in C and Objective-C, the Swift arithmetic operators do not allow values to overflow by default. You can opt in to value overflow behavior by using Swift's overflow operators (such as ). See .
).
 in other languages. However, its behavior in Swift for negative numbers means that it is, strictly speaking, a remainder rather than a modulo operation.
    	
  Here's how the remainder operator works. To calculate  (shown in orange).
.
.
. This means that  always give the same answer.
.
. You can use these operators with variables of any integer or floating-point type.
. Essentially, . Likewise, .
 symbols can be used as prefix operators or as postfix operators. . Similarly, .
 and also return a value. If you only want to increment or decrement the value stored in , you can ignore the returned value. However, if you  returning its value.
 returning its value.
 returning its value. This is why both .
 returning its value. This means that .
 and returning the result.
) is prepended directly before the value it operates on, without any white space.

  Although the unary plus operator doesn't actually do anything, you can use it to provide symmetry in your code for positive numbers when also using the unary minus operator for negative numbers.
) with another operation. One example is the . Effectively, the addition and the assignment are combined into one operator that performs both tasks at the same time.
The compound assignment operators do not return a value. You cannot write , for example. This behavior is different from the increment and decrement operators mentioned above.
    	.
), which you use to test whether two object references both refer to the same object instance. For more information, see .
    	.
. It is a shortcut for evaluating one of two expressions based on whether  is true or false. If  and returns its value.

  Here's an example, which calculates the height for a table row. The row height should be 50 points taller than the content height if the row has a header, and 20 points taller if the row doesn't have a header:
 can be set to the correct value on a single line of code. This is more concise than the second example, and removes the need for  statement.

  The ternary conditional operator provides an efficient shorthand for deciding which of two expressions to consider. Use the ternary conditional operator with care, however. Its conciseness can lead to hard-to-read code if overused. Avoid combining multiple instances of the ternary conditional operator into one compound statement.
. The expression  is always of an optional type. The expression .
 otherwise. The nil coalescing operator provides a more elegant way to encapsulate this conditional checking and unwrapping in a concise and readable form.
 is not evaluated. This is known as .
    	. Because  is of an optional type, you can use the nil coalescing operator to consider its value. In the example above, the operator is used to determine an initial value for a . Because .
, which are shortcuts for expressing a range of values.
. The value of .
.
. It is said to be  because it contains its first value, but not its final value. As with the closed range operator, the value of . If the value of , then the resulting range will be empty.
 (the index of the last item in the array), because it is a half-open range. For more on arrays, see .
. Swift supports the three standard logical operators found in C-based languages:
.

  The logical NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space. It can be read as “not  can be read as “if not allowed entry.” The subsequent line is only executed if “not allowed entry” is true; that is, if .

  As in this example, careful choice of Boolean constant and variable names can help to keep code readable and concise, while avoiding double negatives or confusing logic statements.
.
. In fact, if the . This is known as .
) is an infix operator made from two adjacent pipe characters. You use it to create logical expressions in which only .

  Like the Logical AND operator above, the Logical OR operator uses short-circuit evaluation to consider its expressions. If the left side of a Logical OR expression is , the right side is not evaluated, because it cannot change the outcome of the overall expression.
. Because one value is  operators to create a longer compound expression. However, the  operators still operate on only two values, so this is actually three smaller expressions chained together. The example can be read as:

  If we've entered the correct door code and passed the retina scan, or if we have a valid door key, or if we know the emergency override password, then allow access.
. However, the emergency override password is known, so the overall compound expression still evaluates to .
 are left-associative, meaning that compound expressions with multiple logical operators evaluate the leftmost subexpression first.
    	
  It is sometimes useful to include parentheses when they are not strictly needed, to make the intention of a complex expression easier to read. In the door access example above, it is useful to add parentheses around the first part of the compound expression to make its intent explicit:

  The parentheses make it clear that the first two values are considered as part of a separate possible state in the overall logic. The output of the compound expression doesn't change, but the overall intention is clearer to the reader. Readability is always preferred over brevity; use parentheses where they help to make your intentions clear.
Copyright � 2015 Apple Inc. All rights reserved. . Swift strings are represented by the  type.
 types provide a fast, Unicode-compliant way to work with text in your code. The syntax for string creation and manipulation is lightweight and readable, with a string literal syntax that is similar to C. String concatenation is as simple as adding together two strings with the  operator, and string mutability is managed by choosing between a constant or a variable, just like any other value in Swift.
 type is a fast, modern string implementation. Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.

  You can also use strings to insert constants, variables, literals, and expressions into longer strings, in a process known as string interpolation. This makes it easy to create custom string values for display, storage, and printing.
 class. If you are working with the Foundation framework in Cocoa, the entire . You can also use a  instance.
    	.
. A string literal is a fixed sequence of textual characters surrounded by a pair of double quotes ().
 constant, because it is initialized with a string literal value.
.
    	) to indicate whether a string can be mutated.
    	. If you create a new  when it is passed to a function or method, or when it is assigned to a constant or variable. In each case, a new copy of the existing  value is created, and the new copy is passed or assigned, not the original version. Value types are described in .
 in Cocoa. When you create an . No copying of the string takes place, unless you specifically request it.
    	 value, regardless of where it came from. You can be confident that the string you are passed will not be modified unless you modify it yourself.

  Behind the scenes, Swift's compiler optimizes string usage so that actual copying takes place only when absolutely necessary. This means you always get great performance when working with strings as value types.
 values in a specified order. You can access the individual .
 value must contain a single character only.
    	 value from a mix of constants, variables, literals, and expressions by including their values inside a string literal. Each item that you insert into the string literal is wrapped in a pair of parentheses, prefixed by a backslash:
. This placeholder is replaced with the actual value of  when the string interpolation is evaluated to create an actual string.
 is also part of a larger expression later in the string. This expression calculates the value of ) into the string. In this case, the expression is written as  when it is included inside the string literal.
), and cannot contain a carriage return or line feed.
    	 is an international standard for encoding, representing, and processing text in different writing systems. It enables you to represent almost any character from any language in a standardized form, and to read and write those characters to and from an external source such as a text file or web page. Swift's  types are fully Unicode-compliant, as described in this section.
 values. A Unicode scalar is a unique 21-bit number for a character or modifier, such as ).
 inclusive. Unicode scalars do not include the Unicode  inclusive.
    	
  Note that not all 21-bit Unicode scalars are assigned to a character—some scalars are reserved for future assignment. Scalars that have been assigned to a character typically also have a name, such as  in the examples above.

  The code below shows four examples of these special characters. The  constant contains two escaped double quote characters. The . An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.

  Here's an example. The letter ). However, the same letter can also be represented as a ). The  when it is rendered by a Unicode-aware text-rendering system.
 value that represents an extended grapheme cluster. In the first case, the cluster contains a single scalar; in the second case, it is a cluster of two scalars:
 value. For example, Hangul syllables from the Korean alphabet can be represented as either a precomposed or decomposed sequence. Both of these representations qualify as a single  values means that string concatenation and modification may not always affect a string's character count.
Extended grapheme clusters can be composed of one or more Unicode scalars. This means that different characters—and different representations of the same character—can require different amounts of memory to store. Because of this, characters in Swift do not each take up the same amount of memory within a string's representation. As a result, the number of characters in a string cannot be calculated without iterating through the string to determine its extended grapheme cluster boundaries. If you are working with particularly long string values, be aware that the  function must iterate over the Unicode scalars in the entire string in order to calculate an accurate character count for that string.
    	 that contains the same characters. The length of an  is based on the number of 16-bit code units within the string's UTF-16 representation and not the number of Unicode extended grapheme clusters within the string. To reflect this fact, the  value.

  You access and modify a string through its methods and properties, or by using subscript syntax.
 it contains.
. For this reason, Swift strings cannot be indexed by integer values.
 property to access the posision of the last. If the  are equal.
 method. Any index in a  function. Attempting to access an index outside of a string's range will trigger a runtime error.
 of all of the indexes used to access individual characters in a string.
 method.
 method.
 method.

  Swift provides three ways to compare textual values: string and character equality, prefix equality, and suffix equality.
. Extended grapheme clusters are canonically equivalent if they have the same linguistic meaning and appearance, even if they are composed from different Unicode scalars behind the scenes.
). Both of these extended grapheme clusters are valid ways to represent the character ), as used in Russian. The characters are visually similar, but do not have the same linguistic meaning:
String and character comparisons in Swift are not locale-sensitive.
    	 and return a Boolean value.
.
    	. Each form encodes the string in small chunks known as . These include the UTF-8 encoding form (which encodes a string as 8-bit code units), the UTF-16 encoding form (which encodes a string as 16-bit code units), and the UTF-32 encoding form (which encodes a string as 32-bit code units).

  Swift provides several different ways to access Unicode representations of strings. You can iterate over the string with a  values as Unicode extended grapheme clusters. This process is described in .
 property. This property is of type , whose UTF-8 representation is the same as their ASCII representation. The next three decimal  character. The last four  character.
 property. This property is of type , whose UTF-16 code units have the same values as in the string's UTF-8 representation (because these Unicode scalars represent ASCII characters).
 character. This character can be represented as a single code unit in UTF-16.
 character. These values are a high-surrogate value of ).
 property. This property is of type .
.
 character.
 character.
Copyright � 2015 Apple Inc. All rights reserved. , known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of distinct values. Dictionaries are unordered collections of key-value associations.

  Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store. This means that you cannot insert a value of the wrong type into a collection by mistake. It also means you can be confident about the types of values you will retrieve from a collection. Swift's use of typed arrays, sets, and dictionaries ensures that your code is always clear about the types of values a collection can work with and enables you to catch any type mismatches early in your code's development.
. For more on generic types and collections, see .
    	. This means that you can change (or ) the collection after it is created by adding, removing, or changing items in the collection. Conversely, if you assign an array, a set, or a dictionary to a constant, that collection is , and its size and contents cannot be changed.
It is good practice to create immutable collections in all cases where the collection does not need to change. Doing so enables the Swift compiler to optimize the performance of the collections you create.
    	 stores values of the same type in an ordered list. The same value can appear in an array multiple times at different positions.
 class.
    	.
 is the type of values the array is allowed to store. You can also write the type of an array in shorthand form as . Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of an array.
 from the type of the initializer.
 type also provides an initializer for creating an array of a certain size with all of its values set to a provided default value. You pass this initializer the number of items to be added to the new array (called ). The new array's type is inferred from the type of the two arrays you add together:
, which is a shorthand way to write one or more values as an array collection. An array literal is written as a list of values, separated by commas, surrounded by a pair of square brackets:
. Because this particular array has specified a value type of  values only. Here, the ), written within an array literal.
 introducer) because more items are added to the shopping list in the examples below.
    	 values and nothing else. This matches the type of the  with two initial items.

  Thanks to Swift's type inference, you don't have to write the type of the array if you're initializing it with an array literal containing values of the same type. The initialization of  variable.

  You access and modify an array through its methods and properties, or by using subscript syntax.
. Arrays in Swift are always zero-indexed.

  You can also use subscript syntax to change a range of values at once, even if the replacement set of values has a different length than the range you are replacing. The following example replaces You can't use subscript syntax to append a new item to the end of an array.
    	.
 method. This method removes the item at the specified index and returns the removed item (although you can ignore the returned value if you do not need it):
If you try to access or modify a value for an index that is outside of an array's existing bounds, you will trigger a runtime error. However, you can check that an index is valid before using it, by comparing it to the array's  property. Except when , because arrays are indexed from zero.
    	 property. Like the  function to iterate over the array instead. The  function returns a tuple for each item in the array composed of the index and the value for that item. You can decompose the tuple into temporary constants or variables as part of the iteration:
.
 stores distinct values of the same type in a collection with no defined ordering. You can use sets as an alternative to arrays when the order of items is not important, or when you need to ensure that an item only appears once.
 class.
    	.
 is the type that the set is allowed to store. Unlike arrays, sets do not have an equivalent shorthand form.
, from the type of the initializer.

  You can also initialize a set with an array literal, as a shorthand way to write one or more values as a set collection.
. Because this particular set has specified a value type of  values. Here, the ), written within an array literal.
 introducer) because items are added and removed in the examples below.
    	 must be explicitly declared. However, because of Swift's type inference, you don't have to write the type of the set if you're initializing it with an array literal containing values of the same type. The initialization of  variable.

  You access and modify a set through its methods and properties.
 if the set did not contain it. Alternatively, all items in a set can be removed with its  method.
 method.
 loop.
.
 type does not have a defined ordering. To iterate over the values of a set in a specific order, use the global  function, which returns an ordered collection of the provided sequence.

  You can efficiently perform fundamental set operations, such as combining two sets together, determining which values two sets have in common, or determining whether two sets contain all, some, or none of the same values.
– with the results of various set operations represented by the shaded regions.
 method to create a new set with all of the values in both sets.
 method to create a new set with values not in the specified set.
 method to create a new set with only the values common to both sets.
 method to create a new set with values in either set, but not both.
– with overlapping regions representing elements shared between sets. Set . Conversely, set . Set  with one another, because they share no elements in common.
) to determine whether two sets contain all of the same values.
 method to determine whether all of the values of a set are contained in the specified set, or .
 method to determine whether a set contains all of the values in a specified set, or .
 methods to determine whether a set is a subset or superset, but not equal to, a specified set.
 method to determine whether two sets have any values in common.
 for itself. A hash value is an .
) are hashable by default, and can be used as set value types or dictionary key types. Enumeration member values without associated values (as described in ) are also hashable by default.
 protocol from Swift's standard library. Types that conform to the . The value returned by a type's  property is not required to be the same across different executions of the same program, or in different programs.
    	). The  to be an equivalence relation. That is, an implementation of .
 stores associations between keys of the same type and values of the same type in an collection with no defined ordering. Each value is associated with a unique , which acts as an identifier for that value within the dictionary. Unlike items in an array, items in a dictionary do not have a specified order. You use a dictionary when you need to look up values based on their identifier, in much the same way that a real-world dictionary is used to look up the definition for a particular word.
 class.
    	.
 is the type of value that the dictionary stores for those keys.
 protocol, like a set's value type.
    	. Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of a dictionary.
 to store human-readable names of integer values. Its keys are of type .
, which has a similar syntax to the array literal seen earlier. A dictionary literal is a shorthand way to write one or more key-value pairs as a  collection.
 is a combination of a key and a value. In a dictionary literal, the key and value in each key-value pair are separated by a colon. The key-value pairs are written as a list, separated by commas, surrounded by a pair of square brackets:

  The example below creates a dictionary to store the names of international airports. In this dictionary, the keys are three-letter International Air Transport Association codes, and the values are airport names:
”.
 introducer), because more airports are added to the dictionary in the examples below.
    	 dictionary is initialized with a dictionary literal containing two key-value pairs. The first pair has a key of . The second pair has a key of .
 pairs. This key-value type matches the type of the  dictionary with two initial items.

  As with arrays, you don't have to write the type of the dictionary if you're initializing it with a dictionary literal whose keys and values have consistent types. The initialization of  dictionary.

  You access and modify a dictionary through its methods and properties, or by using subscript syntax. As with an array, you find out the number of items in a 
  You can add a new item to a dictionary with subscript syntax. Use a new key of the appropriate type as the subscript index, and assign a new value of the appropriate type:
 method to set or update the value for a particular key. Like the subscript examples above, the  method sets a value for a key if none exists, or updates the value if that key already exists. Unlike a subscript, however, the  value after performing an update. This enables you to check whether or not an update took place.
 method returns an optional value of the dictionary's value type. For a dictionary that stores ”. This optional value contains the old value for that key if one existed before the update, or 
  You can also use subscript syntax to retrieve a value from the dictionary for a particular key. Because it is possible to request a key for which no value exists, a dictionary's subscript returns an optional value of the dictionary's value type. If the dictionary contains a value for the requested key, the subscript returns an optional value containing the existing value for that key. Otherwise, the subscript returns  method. This method removes the key-value pair if it exists and returns the removed value, or returns  loop. Each item in the dictionary is returned as a .
 type does not have a defined ordering. To iterate over the keys or values of a dictionary in a specific order, use the global  property.
Copyright � 2015 Apple Inc. All rights reserved. 
  Swift provides all the familiar control flow statements from C-like languages. These include  to transfer the flow of execution to another point in your code.
 loop that makes it easy to iterate over arrays, dictionaries, ranges, strings, and other sequences.
 statement is also considerably more powerful than its counterpart in C. The cases of a  statements. Cases can match many different patterns, including interval matches, tuples, and casts to a specific type. Matched values in a  clause for each case.
 loop performs a set of statements for each item in a sequence.
 loop performs a set of statements until a specific condition is met, typically by incrementing a counter each time the loop ends.
 loop to iterate over a sequence, such as ranges of numbers, items in an array, or characters in a string.
). The value of ), and the statements inside the loop are executed. In this case, the loop contains only one statement, which prints an entry from the five-times-table for the current value of . After the statement is executed, the value of  function is called again. This process continues until the end of the range is reached.
 is a constant whose value is automatically set at the start of each iteration of the loop. As such, it does not have to be declared before it is used. It is implicitly declared simply by its inclusion in the loop declaration, without the need for a  declaration keyword.
). It multiplies a starting value of . This calculation doesn't need to know the individual counter values each time through the loop—it simply needs to execute the loop the correct number of times. The underscore character  (used in place of a loop variable) causes the individual values to be ignored and does not provide access to the current value during each iteration of the loop.

  You can also iterate over a dictionary to access its key-value pairs. Each item in the dictionary is returned as a  loop. Here, the dictionary's keys are decomposed into a constant called  may not necessarily be iterated in the same order as they were inserted. The contents of a  are inherently unordered, and iterating over them does not guarantee the order in which they will be retrieved. For more on arrays and dictionaries, see .)

  Semicolons separate the three parts of the loop's definition, as in C. However, unlike C, Swift doesn't need parentheses around the entire “initialization; condition; increment” block.
 is evaluated once, to set up any constants or variables that are needed for the loop.
 is evaluated. If it evaluates to ). If the expression evaluates to , code execution continues by executing the statements inside the braces.
 is evaluated. It might increase or decrease the value of a counter, or set one of the initialized variables to a new value based on the outcome of the statements. After the increment expression has been evaluated, execution returns to step 2, and the condition expression is evaluated again.
 loop itself. To retrieve the final value of . The last time the increment statement , ending the loop.
. These kinds of loops are best used when the number of iterations is not known before the first iteration begins. Swift provides two kinds of  evaluates its condition at the start of each pass through the loop.
 evaluates its condition at the end of each pass through the loop.
 loop starts by evaluating a single condition. If the condition is .

  The board has 25 squares, and the aim is to land on or beyond square 25.

  Each turn, you roll a six-sided dice and move by that number of squares, following the horizontal path indicated by the dotted arrow above.

  If your turn ends at the bottom of a ladder, you move up that ladder.

  If your turn ends at the head of a snake, you move down that snake.
 values. Its size is based on a constant called , which is used to initialize the array and also to check for a win condition later in the example. The board is initialized with 26 zero 
  Some squares are then set to have more specific values for the snakes and ladders. Squares with a ladder base have a positive number to move you up the board, whereas squares with a snake head have a negative number to move you back down the board:

  Square 3 contains the bottom of a ladder that moves you up to square 11. To represent this, ). The unary plus operator ( are padded with zeros so that all board definitions align. (Neither stylistic tweak is strictly necessary, but they lead to neater code.)

  The player's starting square is “square zero”, which is just off the bottom left corner of the board. The first dice roll always moves the player on to the board:

  This example uses a very simple approach to dice rolling. Instead of a random number generator, it starts with a . Each time through the ), and is then checked to see if it has become too large. The return value of  it is incremented. Whenever this return value equals . This gives a sequence of  and so on.
 squares. It's possible that the dice roll may have moved the player beyond square 25, in which case the game is over. To cope with this scenario, the code checks that  value to move the player up or down any ladders or snakes.
 array, which would trigger an error. If , which is larger than the size of the array.
 loop execution then ends, and the loop's condition is checked to see if the loop should be executed again. If the player has moved on or beyond square number , and the game ends.
 loop. Instead, the loop is executed until a particular condition is satisfied.
 considering the loop's condition. It then continues to repeat the loop until the condition is .
 loop. The values of  action in the loop is to check for a ladder or a snake. No ladder on the board takes the player straight to square 25, and so it is not possible to win the game by moving up a ladder. Therefore, it is safe to check for a snake or a ladder as the first action in the loop.

  At the start of the game, the player is on “square zero”.  squares. The current loop execution then ends.
 of the first run through the loop. The structure of the  loop in the previous example. In the  is still on the board. This behavior removes the need for the array bounds check seen in the earlier version of the game.

  It is often useful to execute different pieces of code based on certain conditions. You might want to run an extra piece of code when an error occurs, or to display a message when a value becomes too high or too low. To do this, you make parts of your code .
 statement. Typically, you use the  statement to evaluate simple conditions with only a few possible outcomes. The  statement is better suited to more complex conditions with multiple possible permutations, and is useful in situations where pattern-matching can help select an appropriate code branch to execute.
 condition. It executes a set of statements only if that condition is 
  The preceding example checks whether the temperature is less than or equal to 32 degrees Fahrenheit (the freezing point of water). If it is, a message is printed. Otherwise, no message is printed, and code execution continues after the  statement's closing brace.
. These statements are indicated by the 
  One of these two branches is always executed. Because the temperature has increased to  branch is triggered instead.
 statement is added to respond to particularly warm temperatures. The final  clause remains, and prints a response for any temperatures that are neither too warm nor too cold.
 conditions, and so no message is printed.
 statement considers a value and compares it against several possible matching patterns. It then executes an appropriate block of code, based on the first pattern that matches successfully. A  statement for responding to multiple potential states.
 keyword. In addition to comparing against specific values, Swift provides several ways for each case to specify more complex matching patterns. These options are described later in this section.
 statement. The  statement determines which branch should be selected. This is known as  on the value that is being considered.
. That is, every possible value of the type being considered must be matched by one of the  cases. If it is not appropriate to provide a  case for every possible value, you can define a default catch-all case to cover any values that are not addressed explicitly. This catch-all case is indicated by the keyword , and must always appear last.
 statement's first case matches all five lowercase vowels in the English language. Similarly, its second case matches all lowercase English consonants.
 case to match all other characters that are not vowels or consonants. This provision ensures that the  statement is exhaustive.
 statements in Swift do not fall through the bottom of each case and into the next one by default. Instead, the entire  statement. This makes the  case by mistake.
 statement to match and ignore a particular case, or to break out of a matched case before that case has completed its execution. See  for details.
    	 contain at least one executable statement. It is not valid to write the following code, because the first case is empty:
. Rather, it reports a compile-time error that  does not contain any executable statements. This approach avoids accidental fallthrough from one case to another, and makes for safer code that is clearer in its intent.
.
    	 cases can be checked for their inclusion in an interval. This example uses number intervals to provide a natural-language count for numbers of any size:
. An interval can determine whether it contains a particular element, such as when matching a . A range is a collection of consecutive values, which can be iterated on in a  statement.
    	 statement. Each element of the tuple can be tested against a different value or interval of values. Alternatively, use the underscore () identifier to match any possible value.
 statement determines if the point is at the origin (0, 0); on the red x-axis; on the orange y-axis; inside the blue 4-by-4 box centered on the origin; or outside of the box.
 cases to consider the same value or values. In fact, the point (0, 0) could match all  of the cases in this example. However, if multiple matches are possible, the first matching case is always used. The point (0, 0) would match  first, and so all other matching cases would be ignored.
 case can bind the value or values it matches to temporary constants or variables, for use in the body of the case. This is known as , because the values are “bound” to temporary constants or variables within the case's body.
 statement determines if the point is on the red x-axis, on the orange y-axis, or elsewhere, on neither axis.
. The first case, . Similarly, the second case, .

  Once the temporary constants are declared, they can be used within the case's code block. Here, they are used as shorthand for printing the values with the  function.
 case. The final case, , declares a tuple of two placeholder constants that can match any value. As a result, it matches all possible remaining values, and a  statement exhaustive.
 keyword, because there is no need to modify their values within the body of the case. However, they could have been declared as variables instead, with the  keyword. If this had been done, a temporary variable would have been created and initialized with the appropriate value. Any changes to that variable would only have an effect within the body of the case.
 clause to check for additional conditions.
, or neither.
. These constants are used as part of a  clause, to create a dynamic filter. The  for that value.
 statement exhaustive.
 change the order in which your code is executed, by transferring control from one piece of code to another. Swift has four control transfer statements:
 statements are described below. The .
 statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop. It says “I am done with the current loop iteration” without leaving the loop altogether.
 statement. The loop itself continues to work as usual; only the code within the loop's body is skipped.
    	 keyword whenever it matches a vowel or a space, causing the current iteration of the loop to end immediately and to jump straight to the start of the next iteration. This behavior enables the switch block to match (and ignore) only the vowel and space characters, rather than requiring the block to match every character that should get printed.
 statement ends execution of an entire control flow statement immediately. The  or loop statement earlier than would otherwise be the case.
). No further code from the current iteration of the loop is executed, and no further iterations of the loop are started.
).
 statement. Because Swift's  statement is exhaustive and does not allow empty cases, it is sometimes necessary to deliberately match and ignore a case in order to make your intentions explicit. You do this by writing the  statement as the entire body of the case you want to ignore. When that case is matched by the  statement's execution immediately.
 case that only contains a comment is reported as a compile-time error. Comments are not statements and do not cause a  case to be ignored. Always use a  case.
    	 value and determines whether it represents a number symbol in one of four languages. Multiple values are covered in a single . If a match is found, one of the  to an appropriate integer value.

  After the switch statement completes its execution, the example uses optional binding to determine whether a value was found. The  statement's first four cases.
 case provides a catchall for any characters that are not matched. This  statement as its body. As soon as the  statement.

  Switch statements in Swift do not fall through the bottom of each case and into the next one. Instead, the entire switch statement completes its execution as soon as the first matching case is completed. By contrast, C requires you to insert an explicit  case to prevent fallthrough. Avoiding default fallthrough means that Swift  cases by mistake.
 keyword. The example below uses  and assigns it an initial value. The function then considers the value of  statement. If the value of , to note that the number is prime. It then uses the  case as well. The  statement is complete.
 case at all. There are no other specific cases, and so  case.
 function. In this example, the number  is correctly identified as a prime number.
 case that it causes execution to fall into. The  statement behavior.
    	 statements in Swift to create complex control flow structures. However, loops and  statement to end their execution prematurely. Therefore, it is sometimes useful to be explicit about which loop or  statement to terminate. Similarly, if you have multiple nested loops, it can be useful to be explicit about which loop the  statement should affect.
 statement to end or continue the execution of the labeled statement.

  A labeled statement is indicated by placing a label on the same line as the statement's introducer keyword, followed by a colon. Here's an example of this syntax for a  game that you saw earlier in this chapter. This time around, the game has an extra rule:
 on square 25.

  If a particular dice roll would take you beyond square 25, you must roll again until you roll the exact number needed to land on square 25.
 statement to implement the game's logic. The , to indicate that it is the main game loop for the Snakes and Ladders game.

  The dice is rolled at the start of each loop. Rather than moving the player immediately, a 
  If the dice roll will move the player onto the final square, the game is over. The  loop, which ends the game.
 the final square, the move is invalid, and the player needs to roll again. The  loop iteration and begins the next iteration of the loop.

  In all other cases, the dice roll is a valid move. The player moves forward by  squares, and the game logic checks for any snakes and ladders. The loop then ends, and control returns to the  condition to decide whether another turn is required.
 statement. Using the  label makes it clear which control statement should be terminated.
    	 to jump to the next iteration of the loop. There is only one loop in the game, and so there is no ambiguity as to which loop the  statement will affect. However, there is no harm in using the  statement. Doing so is consistent with the label's use alongside the  statement, and helps make the game's logic clearer to read and understand.
Copyright � 2015 Apple Inc. All rights reserved.  are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed.

  Swift's unified function syntax is flexible enough to express anything from a simple C-style function with no parameter names to a complex Objective-C-style method with local and external parameter names for each parameter. Parameters can provide default values to simplify function calls and can be passed as in-out parameters, which modify a passed variable once the function has completed its execution.

  Every function in Swift has a type, consisting of the function's parameter types and return type. You can use this type like any other type in Swift, which makes it easy to pass functions as parameters to other functions, and to return functions from functions. Functions can also be written within other functions to encapsulate useful functionality within a nested function scope.
).
, which describes the task that the function performs. To use a function, you “call” that function with its name and pass it input values (known as ) that match the types of the function's parameters. A function's arguments must always be provided in the same order as the function's parameter list.
, because that's what it does—it takes a person's name as input and returns a greeting for that person. To accomplish this, you define one input parameter—a  keyword. You indicate the function's return type with the  (a hyphen followed by a right angle bracket), which is followed by the name of the type to return.

  The definition describes what the function does, what it expects to receive, and what it returns when it is done. The definition makes it easy for the function to be called unambiguously from elsewhere in your code:
. Because the function returns a  function to print that string and see its return value, as shown above.
. This greeting is then passed back out of the function using the  keyword. As soon as .
 function multiple times with different input values. The example above shows what happens if it is called with an input value of . The function returns a tailored greeting in each case.

  Function parameters and return values are extremely flexible in Swift. You can define anything from a simple utility function with a single unnamed parameter to a complex function with expressive parameter names and different parameter options.

  Functions can have multiple input parameters, which are written within the function's parentheses, separated by commas.

  Functions are not required to define input parameters. Here's a function with no input parameters, which always returns the same 
  The function definition still needs parentheses after the function's name, even though it does not take any parameters. The function name is also followed by an empty pair of parentheses when the function is called.

  Functions are not required to define a return type. Here's a version of the ) or a return type.
 still return a value, even though no return value is defined. Functions without a defined return type return a special value of type . This is simply an empty tuple, in effect a tuple with zero elements, which can be written as .
    	. The second function, , calls the first function, but ignores its return value. When the second function is called, the message is still printed by the first function, but the returned value is not used.
Return values can be ignored, but a function that says it will return a value must always do so. A function with a defined return type cannot allow control to fall out of the bottom of the function without returning a value, and attempting to do so will result in a compile-time error.
    	
  You can use a tuple type as the return type for a function to return multiple values as part of one compound return value.
 values. These values are labeled  so that they can be accessed by name when querying the function's return value.
 to the value of the first integer in the array. The function then iterates over the remaining values in the array and checks each value to see if it is smaller or larger than the values of  respectively. Finally, the overall minimum and maximum values are returned as a tuple of two  values.

  Note that the tuple's members do not need to be named at the point that the tuple is returned from the function, because their names are already specified as part of the function's return type.
. You write an optional tuple return type by placing a question mark after the tuple type's closing parenthesis, such as .
. With an optional tuple type, the entire tuple is optional, not just each individual value within the tuple.
    	 values. However, the function does not perform any safety checks on the array it is passed. If the .

  However, these parameter names are only used within the body of the function itself, and cannot be used when calling the function. These kinds of parameter names are known as , because they are only available for use within the function's body.
 a function, to indicate the purpose of each argument you pass to the function.
 for each parameter, in addition to the local parameter name. You write an external parameter name before the local parameter name it supports, separated by a space:
 be used when you call the function.
    	.
 function to be called in an expressive, sentence-like manner by users of the function, while still providing a function body that is readable and clear in intent.
Consider using external parameter names whenever the purpose of a function's arguments would be unclear to someone reading your code for the first time. You do not need to specify external parameter names if the purpose of each parameter is unambiguous when the function is called.
    	
  If you want to provide an external parameter name for a function parameter, and the local parameter name is already an appropriate name to use, you do not need to write the same name twice for that parameter. Instead, write the name once, and prefix the name with a hash symbol (). This tells Swift to use that name as both the local parameter name and the external parameter name.
 for any parameter as part of a function's definition. If a default value is defined, you can omit that parameter when calling the function.
Place parameters with default values at the end of a function's parameter list. This ensures that all calls to the function use the same order for their non-default arguments, and makes it clear that the same function is being called in each case.
    	
  In most cases, it is useful to provide (and therefore require) an external name for any parameter with a default value. This ensures that the argument for that parameter is clear in purpose if a value is provided when the function is called.

  To make this process easier, Swift provides an automatic external name for any parameter that has a default value. The automatic external name is the same as the local name, as if you had written a hash symbol before the local name in your code.
 parameter. The external name must therefore be provided when calling the function, making the parameter's purpose clear and unambiguous:
) instead of an explicit external name when you define the parameter. However, external names for parameters with default values are preferred.
    	 accepts zero or more values of a specified type. You use a variadic parameter to specify that the parameter can be passed a varying number of input values when the function is called. Write variadic parameters by inserting three period characters () after the parameter's type name.

  The values passed to a variadic parameter are made available within the function's body as an array of the appropriate type. For example, a variadic parameter with a name of .
A function may have at most one variadic parameter, and it must always appear last in the parameter list, to avoid ambiguity when calling the function with multiple parameters.
    	
  If your function has one or more parameters with a default value, and also has a variadic parameter, place the variadic parameter after all the defaulted parameters at the very end of the list.

  Function parameters are constants by default. Trying to change the value of a function parameter from within the body of that function results in a compile-time error. This means that you can't change the value of a parameter by mistake.
 copy of a parameter's value to work with. You can avoid defining a new variable yourself within the function by specifying one or more parameters as  instead. Variable parameters are available as variables rather than as constants, and give a new modifiable copy of the parameter's value for your function to work with.
, which aligns an input string to the right edge of a longer output string. Any space on the left is filled with a specified padding character. In this example, the string .
 to be a variable parameter. This means that  is now available as a local variable, initialized with the passed-in string value, and can be manipulated within the body of the function.
 in order to right-align it within the overall string. This value is stored in a local constant called . If no padding is needed (that is, if  without any padding.
 to the left of the existing string. (A  values.)
The changes you make to a variable parameter do not persist beyond the end of each call to the function, and are not visible outside the function's body. The variable parameter only exists for the lifetime of that function call.
    	
  Variable parameters, as described above, can only be changed within the function itself. If you want a function to modify a parameter's value, and you want those changes to persist after the function call has ended, define that parameter as an  instead.
 keyword at the start of its parameter definition. An in-out parameter has a value that is passed  of the function to replace the original value.

  You can only pass a variable as the argument for an in-out parameter. You cannot pass a constant or a literal value as the argument, because constants and literals cannot be modified. You place an ampersand () directly before a variable's name when you pass it as an argument to an inout parameter, to indicate that it can be modified by the function.
. If you mark a parameter as .
    	. The function performs this swap by storing the value of .
 to swap their values. Note that the names of  function, even though they were originally defined outside of the function.
In-out parameters are not the same as returning a value from a function. The . In-out parameters are an alternative way for a function to have an effect outside of the scope of its function body.
    	, made up of the parameter types and the return type of the function.
. These functions each take two  value, which is the result of performing an appropriate mathematical operation.
. This can be read as:
.”
.” Functions that don't specify a return value always return .

  You use function types just like any other types in Swift. For example, you can define a constant or variable to be of a function type and assign an appropriate function to that variable:
 value.' Set this new variable to refer to the function called .”
 variable, and so this assignment is allowed by Swift's type-checker.
 as a parameter type for another function. This enables you to leave some aspects of a function's implementation for the function's caller to provide when the function is called.
, which has three parameters. The first parameter is called . You can pass any function of that type as the argument for this first parameter. The second and third parameters are called . These are used as the two input values for the provided math function.
. It calls the provided function with the values .
 is to print the result of a call to a math function of an appropriate type. It doesn't matter what that function's implementation actually does—it matters only that the function is of the correct type. This enables  to hand off some of its functionality to the caller of the function in a type-safe way.

  You can use a function type as the return type of another function. You do this by writing a complete function type immediately after the return arrow () of the returning function.
. The  function returns a value one less than its input value. Both functions have a type of ”.  progressively closer to zero.  function. A reference to the returned function is stored in a constant called .
, which are defined at a global scope. You can also define functions inside the bodies of other functions, known as .

  Nested functions are hidden from the outside world by default, but can still be called and used by their enclosing function. An enclosing function can also return one of its nested functions to allow the nested function to be used in another scope.
Copyright � 2015 Apple Inc. All rights reserved.  are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.

  Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as  over those constants and variables, hence the name “closures”. Swift handles all of the memory management of capturing for you.
Don't worry if you are not familiar with the concept of “capturing”. It is explained in detail below in .
    	, are actually special cases of closures. Closures take one of three forms:

  Global functions are closures that have a name and do not capture any values.

  Nested functions are closures that have a name and can capture values from their enclosing function.

  Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.

  Swift's closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios. These optimizations include:
, are a convenient means of naming and defining self-contained blocks of code as part of a larger function. However, it is sometimes useful to write shorter versions of function-like constructs without a full declaration and name. This is particularly true when you work with functions that take other functions as one or more of their arguments.
 are a way to write inline closures in a brief, focused syntax. Closure expressions provide several syntax optimizations for writing closures in a shortened form without loss of clarity or intent. The closure expression examples below illustrate these optimizations by refining a single example of the  function over several iterations, each of which expresses the same functionality in a more succinct way.
, which sorts an array of values of a known type, based on the output of a sorting closure that you provide. Once it completes the sorting process, the  function returns a new array of the same type and size as the old one, with its elements in the correct sorted order. The original array is not modified by the  function.
 values in reverse alphabetical order. Here's the initial array to be sorted:

  An array of values of a known type.
 value to say whether the first value should appear before or after the second value once the values are sorted. The sorting closure needs to return  otherwise.
.
 in the sorted array. For characters in strings, “greater than” means “appears later in the alphabet than”. This means that the letter . This gives a reverse alphabetical sort, with , and so on.
). In this example, it would be preferable to write the sorting closure inline, using closure expression syntax.
 parameters. Default values cannot be provided. Variadic parameters can be used if you name the variadic parameter and place it last in the parameter list. Tuples can also be used as parameter types and return types.
 function. In both cases, it is written as . However, for the inline closure expression, the parameters and return type are written  the curly braces, not outside of them.
 keyword. This keyword indicates that the definition of the closure's parameters and return type has finished, and the body of the closure is about to begin.
 function has remained the same. A pair of parentheses still wrap the entire set of arguments for the function. However, one of those arguments is now an inline closure.
 function's second parameter. This parameter is expecting a function of type . This means that the  types do not need to be written as part of the closure expression's definition. Because all of the types can be inferred, the return arrow (
  It is always possible to infer the parameter types and return type when passing a closure to a function as an inline closure expression. As a result, you never need to write an inline closure in its fullest form when the closure is used as a function argument.

  Nonetheless, you can still make the types explicit if you wish, and doing so is encouraged if it avoids ambiguity for readers of your code. In the case of the  values, because it is assisting with the sorting of an array of strings.
 value must be returned by the closure. Because the closure's body contains a single expression ( keyword can be omitted.
, and so on.

  If you use these shorthand argument names within your closure expression, you can omit the closure's argument list from its definition, and the number and type of the shorthand argument names will be inferred from the expected function type. The  arguments.
 way to write the closure expression above. Swift's . This exactly matches the function type needed for the  function's second parameter. Therefore, you can simply pass in the greater-than operator, and Swift will infer that you want to use its string-specific implementation:
.
 instead. A trailing closure is a closure expression that is written outside of (and  after the function's name when you call the function.
    	
  Trailing closures are most useful when the closure is sufficiently long that it is not possible to write it inline on a single line. As an example, Swift's  method which takes a closure expression as its single argument. The closure is called once for each item in the array, and returns an alternative mapped value (possibly of some other type) for that item. The nature of the mapping and the type of the returned value is left up to the closure to specify.
 method returns a new array containing all of the new mapped values, in the same order as their corresponding values in the original array.
 values. The array 
  The code above creates a dictionary of mappings between the integer digits and English-language versions of their names. It also defines an array of integers, ready to be converted into strings.
 method as a trailing closure. Note that the call to  method calls the closure expression once for each item in the array. You do not need to specify the type of the closure's input parameter, , because the type can be inferred from the values in the array to be mapped.
 value to it. The closure expression also specifies a return type of , to indicate the type that will be stored in the mapped output array.
 each time it is called. It calculates the last digit of  dictionary. The closure can be used to create a string representation of any integer number greater than zero.
), because dictionary subscripts return an optional value to indicate that the dictionary lookup can fail if the key does not exist. In the example above, it is guaranteed that  value stored in the subscript's optional return value.
    	, effectively building a string version of the number in reverse. (The expression .)
. Because it is an integer, it is rounded down during the division, so .
 function.
 function's outer parentheses.
 constants and variables from the surrounding context in which it is defined. The closure can then refer to and modify the values of those constants and variables from within its body, even if the original scope that defined the constants and variables no longer exists.

  In Swift, the simplest form of a closure that can capture values is a nested function, written within the body of another function. A nested function can capture any of its outer function's arguments and can also capture any constants and variables defined within the outer function.
. The nested , from its surrounding context. After capturing these values,  each time it is called.
. This means that it returns a , rather than a simple value. The function it returns has no parameters, and returns an  value each time it is called. To learn how functions can return other functions, see .
, to store the current running total of the incrementer that will be returned. This variable is initialized with a value of .
. The argument value passed to this parameter specifies how much  should be incremented by each time the returned incrementer function is called.
, which performs the actual incrementing. This function simply adds , and returns the result.
 from within its function body. It does this by capturing the  from its surrounding function and using them within its own function body.
 variable, and not just a copy of its initial value. Capturing a reference ensures that  function is called..
. This value is stored along with the new  function.
Swift determines what should be captured by reference and what should be copied by value. You don't need to annotate  function. Swift also handles all memory management involved in disposing of  function.
    	 variable each time it is called. Calling the function multiple times shows this behavior in action:
If you assign a closure to a property of a class instance, and the closure captures that instance by referring to the instance or its members, you will create a strong reference cycle between the closure and the instance. Swift uses  to break these strong reference cycles. For more information, see .
    	 variables that they have captured. This is because functions and closures are .
 to the function or closure. In the example above, it is the choice of closure that  that is constant, and not the contents of the closure itself.
Copyright � 2015 Apple Inc. All rights reserved.  defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.

  If you are familiar with C, you will know that C enumerations assign related names to a set of integer values. Enumerations in Swift are much more flexible, and do not have to provide a value for each member of the enumeration. If a value (known as a “raw” value)  provided for each enumeration member, the value can be a string, a character, or a value of any integer or floating-point type.
 type to be stored along with each different member value, much as unions or variants do in other languages. You can define a common set of related members as part of one enumeration, each of which has a different set of values of appropriate types associated with it.

  Enumerations in Swift are first-class types in their own right. They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration's current value, and instance methods to provide functionality related to the values the enumeration represents. Enumerations can also define initializers to provide an initial member value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.
.
) of that enumeration. The  keyword indicates that a new line of member values is about to be defined.
Unlike C and Objective-C, Swift enumeration members are not assigned a default integer value when they are created. In the . Instead, the different enumeration members are fully-fledged values in their own right, with an explicitly-defined type of .
    	
  Each enumeration definition defines a brand new type. Like other types in Swift, their names (such as ) should start with a capital letter. Give enumeration types singular rather than plural names, so that they read as self-evident:
. Once  is already known, and so you can drop the type when setting its value. This makes for highly readable code when working with explicitly-typed enumeration values.
. In the case where it equals . In the case where it equals .”

  …and so on.
 statement must be exhaustive when considering an enumeration's members. If the  members. Requiring exhaustiveness ensures that enumeration members are not accidentally omitted.

  The examples in the previous section show how the members of an enumeration are a defined (and typed) value in their own right. You can set a constant or variable to , and check for this value later. However, it is sometimes useful to be able to store  of other types alongside these member values. This enables you to store additional custom information along with the member value, and permits this information to vary each time you use that member in your code.

  You can define Swift enumerations to store associated values of any given type, and the value types can be different for each member of the enumeration if needed. Enumerations similar to these are known as  in other programming languages.

  For example, suppose an inventory tracking system needs to track products by two different types of barcode. Some products are labeled with 1D barcodes in UPC-A format, which uses the numbers . Each barcode has a “number system” digit, followed by five “manufacturer code” digits and five “product code” digits. These are followed by a “check” digit to verify that the code has been scanned correctly:

  It would be convenient for an inventory tracking system to be able to store UPC-A barcodes as a tuple of four integers, and QR code barcodes as a string of any length.
.”
.
.
 and its string value. Constants and variables of type  (together with their associated values), but they can only store one of them at any given time.

  The different barcode types can be checked using a switch statement, as before. This time, however, the associated values can be extracted as part of the switch statement. You extract each associated value as a constant (with the  shows how members of an enumeration can declare that they store associated values of different types. As an alternative to associated values, enumeration members can come prepopulated with default values (called ), which are all of the same type.
, and are set to some of the more common ASCII control characters. .
 the same as associated values. Raw values are set to prepopulated values when you first define the enumeration in your code, like the three ASCII codes above. The raw value for a particular enumeration member is always the same. Associated values are set when you create a new constant or variable based on one of the enumeration's members, and can be different each time you do so.

  Raw values can be strings, characters, or any of the integer or floating-point number types. Each raw value must be unique within its enumeration declaration. When integers are used for raw values, they auto-increment if no value is specified for some of the enumeration members.
, and so on.
. You can use this initializer to try to create a new instance of the enumeration.
 values will find a matching planet, however. Because of this, the raw value initializer always returns an  enumeration member. In the example above, .”
The raw value initializer is a failable initializer, because not every raw value will return an enumeration member. For more information, see .
    	. The statement  if it can be retrieved. In this case, it is not possible to retrieve a planet with a position of  branch is executed instead.
Copyright � 2015 Apple Inc. All rights reserved.  are general-purpose, flexible constructs that become the building blocks of your program's code. You define properties and methods to add functionality to your classes and structures by using exactly the same syntax as for constants, variables, and functions.

  Unlike other programming languages, Swift does not require you to create separate interface and implementation files for custom classes and structures. In Swift, you define a class or a structure in a single file, and the external interface to that class or structure is automatically made available for other code to use.
. However, Swift classes and structures are much closer in functionality than in other languages, and much of this chapter describes functionality that can apply to instances of  a class or a structure type. Because of this, the more general term  is used.
    	
  Classes and structures in Swift have many things in common. Both can:
.

  Inheritance enables one class to inherit the characteristics of another.

  Type casting enables you to check and interpret the type of a class instance at runtime.

  Deinitializers enable an instance of a class to free up any resources it has assigned.

  Reference counting allows more than one reference to a class instance.
.
Structures are always copied when they are passed around in your code, and do not use reference counting.
    	
  Classes and structures have a similar definition syntax. You introduce classes with the  keyword. Both place their entire definition within a pair of braces:
Whenever you define a new class or structure, you effectively define a brand new Swift type. Give types ). Conversely, always give properties and methods ) to differentiate them from type names.
    	, to describe a pixel-based display resolution. This structure has two stored properties called . Stored properties are constants or variables that are bundled up and stored as part of the class or structure. These two properties are inferred to be of type .
, to describe a specific video mode for video display. This class has four variable stored properties. The first, . For the other three properties, new . The  value”, because it is of an optional type.
 will look like. They themselves do not describe a specific resolution or video mode. To do that, you need to create an instance of the structure or class.

  Structures and classes both use initializer syntax for new instances. The simplest form of initializer syntax uses the type name of the class or structure followed by empty parentheses, such as . This creates a new instance of the class or structure, with any properties initialized to their default values. Class and structure initialization is described in more detail in .
. In dot syntax, you write the property name immediately after the instance name, separated by a period (.
Unlike Objective-C, Swift enables you to set sub-properties of a structure property directly. In the last example above, the  property to a new value.
    	, which you can use to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name:

  Unlike structures, class instances do not receive a default memberwise initializer. Initializers are described in more detail in .
 when it is assigned to a variable or constant, or when it is passed to a function.

  You've actually been using value types extensively throughout the previous chapters. In fact, all of the basic types in Swift—integers, floating-point numbers, Booleans, strings, arrays and dictionaries—are value types, and are implemented as structures behind the scenes.

  All structures and enumerations are value types in Swift. This means that any structure and enumeration instances you create—and any value types they have as properties—are always copied when they are passed around in your code.
 pixels high).
. Because . Even though  now have the same width and height, they are two completely different instances behind the scenes.
 instance. The end result is two completely separate instances, which just happened to contain the same numeric values. Because they are separate instances, setting the width of .
, it is actually set to a copy of that value. Changing the value of .
 copied when they are assigned to a variable or constant, or when they are passed to a function. Rather than a copy, a reference to the same existing instance is used instead.
 class. The video mode is assigned a copy of the HD resolution of  from before. It is set to be interlaced, and is given a name of . Finally, it is set to a frame rate of  frames per second.
 instance. Effectively, they are just two different names for the same single instance.
, rather than variables. However, you can still change  constants themselves do not actually change.  instance behind the scenes. It is the .

  Because classes are reference types, it is possible for multiple constants and variables to refer to the same single instance of a class behind the scenes. (The same is not true for structures and enumerations, because they are always copied when they are assigned to a constant or variable, or passed to a function.)

  It can sometimes be useful to find out if two constants or variables refer to exactly the same instance of a class. To enable this, Swift provides two identity operators:

  “Identical to” means that two constants or variables of class type refer to exactly the same class instance.

  “Equal to” means that two instances are considered “equal” or “equivalent” in value, for some appropriate meaning of “equal”, as defined by the type's designer.

  When you define your own custom classes and structures, it is your responsibility to decide what qualifies as two instances being “equal”. The process of defining your own implementations of the “equal to” and “not equal to” operators is described in .
 to refer to addresses in memory. A Swift constant or variable that refers to an instance of some reference type is similar to a pointer in C, but is not a direct pointer to an address in memory, and does not require you to write an asterisk () to indicate that you are creating a reference. Instead, these references are defined like any other constant or variable in Swift.

  You can use both classes and structures to define custom data types to use as the building blocks of your program's code.
. This means that they are suited to different kinds of tasks. As you consider the data constructs and functionality that you need for a project, decide whether each data construct should be defined as a class or as a structure.

  The structure's primary purpose is to encapsulate a few relatively simple data values.

  It is reasonable to expect that the encapsulated values will be copied rather than referenced when you assign or pass around an instance of that structure.

  Any properties stored by the structure are themselves value types, which would also be expected to be copied rather than referenced.

  The structure does not need to inherit properties or behavior from another existing type.
.
.
.

  In all other cases, define a class, and create instances of that class to be managed and passed by reference. In practice, this means that most custom data constructs should be classes, not structures.
 types are implemented as structures. This means that strings, arrays, and dictionaries are copied when they are assigned to a new constant or variable, or when they are passed to a function or method.
 in Foundation, which are implemented as classes, not structures.  instances are always assigned and passed around as a reference to an existing instance, rather than as a copy.
The description above refers to the “copying” of strings, arrays, and dictionaries. The behavior you see in your code will always be as if a copy took place. However, Swift only performs an  copy behind the scenes when it is absolutely necessary to do so. Swift manages all value copying to ensure optimal performance, and you should not avoid assignment to try to preempt this optimization.
    	Copyright � 2015 Apple Inc. All rights reserved.  associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures.

  Stored and computed properties are usually associated with instances of a particular type. However, properties can also be associated with the type itself. Such properties are known as type properties.

  In addition, you can define property observers to monitor changes in a property's value, which you can respond to with custom actions. Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.

  In its simplest form, a stored property is a constant or variable that is stored as part of an instance of a particular class or structure. Stored properties can be either  keyword).
. You can also set and modify the initial value for a stored property during initialization. This is true even for constant stored properties, as described in .
. In the example above,  is initialized when the new range is created and cannot be changed thereafter, because it is a constant property.
 is a variable property.
. When an instance of a value type is marked as a constant, so are all of its properties.
. If you assign an instance of a reference type to a constant, you can still change that instance's variable properties.
 is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the  modifier before its declaration.
 keyword), because its initial value might not be retrieved until after instance initialization completes. Constant properties must always have a value  initialization completes, and therefore cannot be declared as lazy.
    	
  Lazy properties are useful when the initial value for a property is dependent on outside factors whose values are not known until after an instance's initialization is complete. Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed.

  The example below uses a lazy stored property to avoid unnecessary initialization of a complex class. This example defines two classes called  values. Although the rest of its functionality is not shown, the purpose of this  data.
 class is the ability to import data from a file. This functionality is provided by the  class, which is assumed to take a non-trivial amount of time to initialize. This might be because a  instance is initialized.
 itself is created. Instead, it makes more sense to create the  instance if and when it is first used.
 ways to store values and references as part of a class instance. In addition to properties, you can use instance variables as a backing store for the values stored in a property.

  Swift unifies these concepts into a single property declaration. A Swift property does not have a corresponding instance variable, and the backing store for a property is not accessed directly. This approach avoids confusion about how the value is accessed in different contexts and simplifies the property's declaration into a single, definitive statement. All information about the property—including its name, type, and memory management characteristics—is defined in a single location as part of the type's definition.
, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.
 coordinate.
.
 defines a rectangle by an origin point and a size.
. The current center position of a  value. Instead,  as if it were a real stored property.
. The . This square is represented by the blue square in the diagram below.
 to be called, to retrieve the current property value. Rather than returning an existing value, the getter actually calculates and returns a new  to represent the center of the square. As can be seen above, the getter correctly returns a center point of .
, which moves the square up and to the right, to the new position shown by the orange square in the diagram below. Setting the  property, and moves the square to its new position.
 is used. Here's an alternative version of the . A read-only computed property always returns a value, and can be accessed through dot syntax, but cannot be set to a different value.
 keyword, because their value is not fixed. The  keyword is only used for constant properties, to indicate that their values cannot be changed once they are set as part of instance initialization.
    	 properties. This structure also has a read-only computed property called , which calculates and returns the current volume of the cuboid. It doesn't make sense for  value. Nonetheless, it is useful for a  to provide a read-only computed property to enable external users to discover its current calculated volume.
 observe and respond to changes in a property's value. Property observers are called every time a property's value is set, even if the new value is the same as the property's current value.

  You can add property observers to any stored properties you define, apart from lazy stored properties. You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass. Property overriding is described in .
You don't need to define property observers for non-overridden computed properties, because you can observe and respond to changes to their value from directly within the computed property's setter.
    	 is called just before the value is stored.
 is called immediately after the new value is stored.
 observer, it is passed the new property value as a constant parameter. You can specify a name for this parameter as part of your  implementation. If you choose not to write the parameter name and parentheses within your implementation, the parameter will still be made available with a default parameter name of .
 observer, it will be passed a constant parameter containing the old property value. You can name the parameter if you wish, or use the default parameter name of .
 observers are not called when a property is set in an initializer before delegation takes place.
    	.
 in action. The example below defines a new class called , which tracks the total number of steps that a person takes while walking. This class might be used with input data from a pedometer or other step counter to keep track of a person's exercise during their daily routine.
. This is a stored property with  observers.
 are called whenever the property is assigned a new value. This is true even if the new value is the same as the current value.
 for the upcoming new value. In this example, it simply prints out the value that is about to be set.
 is updated. It compares the new value of  against the old value. If the total number of steps has increased, a message is printed to indicate how many new steps have been taken. The  is used instead.
 observer, the new value that you assign will replace the one that was just set.
    	. Global variables are variables that are defined outside of any function, method, closure, or type context. Local variables are variables that are defined within a function, method, or closure context.
. Stored variables, like stored properties, provide storage for a value of a certain type and allow that value to be set and retrieved.
 and define observers for stored variables, in either a global or local scope. Computed variables calculate rather than store a value, and are written in the same way as computed properties.
. Unlike lazy stored properties, global constants and variables do not need to be marked with the  modifier.
    	
  Local constants and variables are never computed lazily.

  Instance properties are properties that belong to an instance of a particular type. Every time you create a new instance of that type, it has its own set of property values, separate from any other instance.

  You can also define properties that belong to the type itself, not to any one instance of that type. There will only ever be one copy of these properties, no matter how many instances of that type you create. These kinds of properties are called .
 instances of a particular type, such as a constant property that all instances can use (like a static constant in C), or a variable property that stores a value that is global to all instances of that type (like a static variable in C).

  For value types (that is, structures and enumerations), you can define stored and computed type properties. For classes, you can define computed type properties only.

  Stored type properties for value types can be variables or constants. Computed type properties are always declared as variable properties, in the same way as computed instance properties.
Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.
    	 static variables. In Swift, however, type properties are written as part of the type's definition, within the type's outer curly braces, and each type property is explicitly scoped to the type it supports.
 keyword. For computed type properties for class types, you can use the  keyword instead to allow subclasses to override the superclass's implementation. The example below shows the syntax for stored and computed type properties:
The computed type property examples above are for read-only computed type properties, but you can also define read-write computed type properties with the same syntax as for computed instance properties.
    	
  Type properties are queried and set with dot syntax, just like instance properties. However, type properties are queried and set on the , not on an instance of that type. For example:

  The examples that follow use two stored type properties as part of a structure that models an audio level meter for a number of audio channels. Each channel has an integer audio level between  inclusive.

  The figure below illustrates how two of these audio channels can be combined to model a stereo audio level meter. When a channel's audio level is , none of the lights for that channel are lit. When the audio level is , all of the lights for that channel are lit. In this figure, the left channel has a current level of  structure defines two stored type properties to support its functionality. The first, , defines the maximum threshold value an audio level can take. This is a constant value of  instances. If an audio signal comes in with a higher value than , it will be capped to this threshold value (as described below).
. This keeps track of the maximum input value that has been received by  instance. It starts with an initial value of .
.
 whenever it is set. This observer performs two checks:
.
 type property.
 to a different value. This does not, however, cause the observer to be called again.
    	Copyright � 2015 Apple Inc. All rights reserved.  are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C.

  The fact that structures and enumerations can define methods in Swift is a major difference from C and Objective-C. In Objective-C, classes are the only types that can define methods. In Swift, you can choose whether to define a class, structure, or enumeration, and still have the flexibility to define methods on the type you create.
 are functions that belong to instances of a particular class, structure, or enumeration. They support the functionality of those instances, either by providing ways to access and modify instance properties, or by providing functionality related to the instance's purpose. Instance methods have exactly the same syntax as functions, as described in .

  You write an instance method within the opening and closing braces of the type it belongs to. An instance method has implicit access to all other instance methods and properties of that type. An instance method can be called only on a specific instance of the type it belongs to. It cannot be called in isolation without an existing instance.
.
 increments the counter by a specified integer amount.
 resets the counter to zero.
, to keep track of the current counter value.
. The same is true for method parameters, because methods are just functions that are associated with a type. However, the default behavior of local names and external names is different for functions and methods.

  Methods in Swift are very similar to their counterparts in Objective-C. As in Objective-C, the name of a method in Swift typically refers to the method's first parameter using a preposition such as  class example. The use of a preposition enables the method to be read as a sentence when it is called. Swift makes this established method naming convention easy to write by using a different default approach for method parameters than it uses for function parameters.
 external parameter names by default. This convention matches the typical naming and calling convention you will be familiar with from writing Objective-C methods, and makes for expressive method calls without the need to qualify your parameter names.
. By default, Swift treats  an external name. You call the method as follows:
. The second argument, however, is qualified by an external parameter name to make its purpose clear when the method is called.

  The default behavior described above means that method definitions in Swift are written with the same grammatical style as Objective-C, and are called in a natural, expressive way.

  Sometimes it's useful to provide an external parameter name for a method's first parameter, even though this is not the default behavior. You can either add an explicit external name yourself, or you can prefix the first parameter's name with a hash symbol to use the local name as an external name too.
) as an explicit external parameter name for that parameter.
, which is exactly equivalent to the instance itself. You use the  property to refer to the current instance within its own instance methods.
 in your code very often. If you don't explicitly write , Swift assumes that you are referring to a property or method of the current instance whenever you use a known property or method name within a method. This assumption is demonstrated by the use of .

  The main exception to this rule occurs when a parameter name for an instance method has the same name as a property of that instance. In this situation, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way. You use the  property to distinguish between the parameter name and the property name.
.
. By default, the properties of a value type cannot be modified from within its instance methods.
 behavior for that method. The method can then mutate (that is, change) its properties from within the method, and any changes that it makes are written back to the original structure when the method ends. The method can also assign a completely new instance to its implicit  property, and this new instance will replace the existing one when the method ends.
 instance by a certain amount. Instead of returning a new point, this method actually modifies the point on which it is called. The  keyword is added to its definition to enable it to modify its properties.
 property. The  values are set to the target location. The end result of calling this alternative version of the method will be exactly the same as for calling the earlier version.

  This example defines an enumeration for a three-state switch. The switch cycles between three different power states ( method is called.

  Instance methods, as described above, are methods that are called on an instance of a particular type. You can also define methods that are called on the type itself. These kinds of methods are called . You indicate type methods by writing the keyword  keyword. Classes may also use the  keyword to allow subclasses to override the superclass's implementation of that method.
In Objective-C, you can define type-level methods only for Objective-C classes. In Swift, you can define type-level methods for all classes, structures, and enumerations. Each type method is explicitly scoped to the type it supports.
    	
  Type methods are called with dot syntax, like instance methods. However, you call type methods on the type, not on an instance of that type. Here's how you call a type method on a class called  property refers to the type itself, rather than an instance of that type. For structures and enumerations, this means that you can use  to disambiguate between type properties and type method parameters, just as you do for instance properties and instance method parameters.

  More generally, any unqualified method and property names that you use within the body of a type method will refer to other type-level methods and properties. A type method can call another type method with the other method's name, without needing to prefix it with the type name. Similarly, type methods on structures and enumerations can access type properties by using the type property's name without a type name prefix.
, which tracks a player's progress through the different levels or stages of a game. It is a single-player game, but can store information for multiple players on a single device.

  All of the game's levels (apart from level one) are locked when the game is first played. Every time a player finishes a level, that level is unlocked for all players on the device. The  structure uses type properties and methods to keep track of which levels of the game have been unlocked. It also tracks the current level for an individual player.
 structure keeps track of the highest level that any player has unlocked. This value is stored in a type property called .
 property. The first is a type function called  whenever a new level is unlocked. The second is a convenience type function called  if a particular level number is already unlocked. (Note that these type methods can access the .)
 tracks an individual player's progress through the game. It uses an instance property called  to track the level that a player is currently playing.
. Before updating , this method checks whether the requested new level is already unlocked. The .
 to track that player's progress. It also provides a method called , which is called whenever a player completes a particular level. This method unlocks the next level for all players and updates the player's progress to move them to the next level. (The Boolean return value of  on the previous line.)
Copyright � 2015 Apple Inc. All rights reserved. , which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an .

  You can define multiple subscripts for a single type, and the appropriate subscript overload to use is selected based on the type of index value you pass to the subscript. Subscripts are not limited to a single dimension, and you can define subscripts with multiple input parameters to suit your custom type's needs.

  Subscripts enable you to query instances of a type by writing one or more values in square brackets after the instance name. Their syntax is similar to both instance method syntax and computed property syntax. You write subscript definitions with the  keyword, and specify one or more input parameters and a return type, in the same way as instance methods. Unlike instance methods, subscripts can be read-write or read-only. This behavior is communicated by a getter and setter in the same way as for computed properties:
 is the same as the return value of the subscript. As with computed properties, you can choose not to specify the setter's  parameter. A default parameter called  is provided to your setter if you do not provide one yourself.
 is created to represent the three-times-table. This is indicated by passing a value of  parameter.
. This requests the sixth entry in the three-times-table, which returns a value of .
-times-table is based on a fixed mathematical rule. It is not appropriate to set  is defined as a read-only subscript.
    	
  The exact meaning of “subscript” depends on the context in which it is used. Subscripts are typically used as a shortcut for accessing the member elements in a collection, list, or sequence. You are free to implement subscripts in the most appropriate way for your particular class or structure's functionality.
 instance. You can set a value in a dictionary by providing a key of the dictionary's key type within subscript braces, and assigning a value of the dictionary's value type to the subscript:
 and initializes it with a dictionary literal containing three key-value pairs. The type of the . After creating the dictionary, this example uses subscript assignment to add a  to the dictionary.
.
 type. For the , or “optional int”. The  value for that key.
    	
  Subscripts can take any number of input parameters, and these input parameters can be of any type. Subscripts can also return any type. Subscripts can use variable parameters and variadic parameters, but cannot use in-out parameters or provide default parameter values.

  A class or structure can provide as many subscript implementations as it needs, and the appropriate subscript to be used will be inferred based on the types of the value or values that are contained within the subscript braces at the point that the subscript is used. This definition of multiple subscripts is known as .

  While it is most common for a subscript to take a single parameter, you can also define a subscript with multiple parameters if it is appropriate for your type. The following example defines a  values. The . Each position in the matrix is given an initial value of . To achieve this, the array's size, and an initial cell value of , are passed to an array initializer that creates and initializes a new array of the correct size. This initializer is described in more detail in .
 instance with two rows and two columns. The  values are valid. To assist with these assertions, Copyright � 2015 Apple Inc. All rights reserved.  methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a . Inheritance is a fundamental behavior that differentiates classes from other types in Swift.

  Classes in Swift can call and access methods, properties, and subscripts belonging to their superclass and can provide their own overriding versions of those methods, properties, and subscripts to refine or modify their behavior. Swift helps to ensure your overrides are correct by checking that the override definition has a matching superclass definition.

  Classes can also add property observers to inherited properties in order to be notified when the value of a property changes. Property observers can be added to any property, regardless of whether it was originally defined as a stored or computed property.
.
Swift classes do not inherit from a universal base class. Classes you define without specifying a superclass automatically become base classes for you to build upon.
    	. This base class defines a stored property called ). The  to create a description of the vehicle.
. This method does not actually do anything for a base  class defines common characteristics for an arbitrary vehicle, but is not much use in itself. To make it more useful, you need to refine it to describe more specific kinds of vehicle.
 is the act of basing a new class on an existing class. The subclass inherits characteristics from the existing class, which you can then refine. You can also add new characteristics to the subclass.
 method.
 for the property).
 instance you create will not have a basket. You can set the 
  Subclasses can themselves be subclassed. The next example creates a subclass of . The .

  A subclass can provide its own custom implementation of an instance method, type method, instance property, type property, or subscript that it would otherwise inherit from a superclass. This is known as .
 keyword. Doing so clarifies that you intend to provide an override and have not provided a matching definition by mistake. Overriding by accident can cause unexpected behavior, and any overrides without the  keyword are diagnosed as an error when your code is compiled.
 keyword also prompts the Swift compiler to check that your overriding class's superclass (or one of its parents) has a declaration that matches the one you provided for the override. This check ensures that your overriding definition is correct.

  When you provide a method, property, or subscript override for a subclass, it is sometimes useful to use the existing superclass implementation as part of your override. For example, you can refine the behavior of that existing implementation, or store a modified value in an existing inherited variable.
 within the overriding method implementation.
 within the overriding getter or setter implementation.
 from within the overriding subscript implementation.

  You can override an inherited instance or type method to provide a tailored or alternative implementation of the method within your subclass.

  You can override an inherited instance or class property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes.
 inherited property, regardless of whether the inherited property is implemented as a stored or computed property at source. The stored or computed nature of an inherited property is not known by a subclass—it only knows that the inherited property has a certain name and type. You must always state both the name and the type of the property you are overriding, to enable the compiler to check that your override matches a superclass property with the same name and type.

  You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override. You cannot, however, present an inherited read-write property as a read-only property.
If you provide a setter as part of a property override, you must also provide a getter for that override. If you don't want to modify the inherited property's value within the overriding getter, you can simply pass through the inherited value by returning  is the name of the property you are overriding.
    	. The . The  property. The  then adds some extra text onto the end of this description to provide information about the current gear.

  You can use property overriding to add property observers to an inherited property. This enables you to be notified when the value of an inherited property changes, regardless of how that property was originally implemented. For more information on property observers, see .
You cannot add property observers to inherited constant stored properties or inherited read-only computed properties. The value of these properties cannot be set, and so it is not appropriate to provide a  implementation as part of an override.
    	
  Note also that you cannot provide both an overriding setter and an overriding property observer for the same property. If you want to observe changes to a property's value, and you are already providing a custom setter for that property, you can simply observe any value changes from within the custom setter.
. The  property to an appropriate choice of gear for the new speed. Specifically, the property observer chooses a gear that is the new . A speed of . Do this by writing the ).

  Any attempt to override a final method, property, or subscript in a subclass is reported as a compile-time error. Methods, properties, or subscripts that you add to a class in an extension can also be marked as final within the extension's definition.
). Any attempt to subclass a final class is reported as a compile-time error.
Copyright � 2015 Apple Inc. All rights reserved.  is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that is required before the new instance is ready for use.
, which are like special methods that can be called to create a new instance of a particular type. Unlike Objective-C initializers, Swift initializers do not return a value. Their primary role is to ensure that new instances of a type are correctly initialized before they are used for the first time.
, which performs any custom cleanup just before an instance of that class is deallocated. For more information about deinitializers, see .
 set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties cannot be left in an indeterminate state.

  You can set an initial value for a stored property within an initializer, or by assigning a default property value as part of the property's definition. These actions are described in the following sections.
When you assign a default value to a stored property, or set its initial value within an initializer, the value of that property is set directly, without calling any property observers.
    	 are called to create a new instance of a particular type. In its simplest form, an initializer is like an instance method with no parameters, written using the  to store temperatures expressed in the Fahrenheit scale. The  (the freezing point of water when expressed in the Fahrenheit scale).

  You can set the initial value of a stored property from within an initializer, as shown above. Alternatively, specify a  as part of the property's declaration. You specify a default property value by assigning an initial value to the property when it is defined.
If a property always takes the same initial value, provide a default value rather than setting a value within an initializer. The end result is the same, but the default value ties the property's initialization more closely to its declaration. It makes for shorter, clearer initializers and enables you to infer the type of the property from its default value. The default value also makes it easier for you to take advantage of default initializers and initializer inheritance, as described later in this chapter.
    	
  You can customize the initialization process with input parameters and optional property types, or by assigning constant properties during initialization, as described in the following sections.
 as part of an initializer's definition, to define the types and names of values that customize the initialization process. Initialization parameters have the same capabilities and syntax as function and method parameters.
, which stores temperatures expressed in the Celsius scale. The . The second initializer has a single initialization parameter with an external name of . Both initializers convert their single argument into a value in the Celsius scale and store this value in a property called .

  As with function and method parameters, initialization parameters can have both a local name for use within the initializer's body and an external name for use when calling the initializer.

  However, initializers do not have an identifying function name before their parentheses in the way that functions and methods do. Therefore, the names and types of an initializer's parameters play a particularly important role in identifying which initializer should be called. Because of this, Swift provides an automatic external name for  parameter in an initializer if you don't provide an external name yourself. This automatic external name is the same as the local name, as if you had written a hash symbol before every initialization parameter.
. These properties store a value between  to indicate the amount of red, green, and blue in the color.
 for its red, green, and blue components.  parameter, which is used to provide the same value for all three color components.

  Note that it is not possible to call these initializers without using external parameter names. External names must always be used in an initializer if they are defined, and omitting them is a compile-time error:
) instead of an explicit external name for that parameter to override the default behavior.
 is clear in its intent without the need for an external parameter name. It is therefore appropriate to write this initializer as  value.
 type. Properties of optional type are automatically initialized with a value of , indicating that the property is deliberately intended to have “no value yet” during initialization.
”. It is automatically assigned a default value of  is initialized.

  You can assign a value to a constant property at any point during initialization, as long as it is set to a definite value by the time initialization finishes. Once a constant property is assigned a value, it can't be further modified.
For class instances, a constant property can only be modified during initialization by the class that introduces it. It cannot be modified by a subclass.
    	 is created. Even though the  for any structure or base class that provides default values for all of its properties and does not provide at least one initializer itself. The default initializer simply creates a new instance with all of its properties set to their default values.
 automatically gains a default initializer implementation that creates a new instance with all of its properties set to their default values. (The , even though this value is not written in the code.) The example above uses the default initializer for the .
 if they do not define any of their own custom initializers. Unlike a default initializer, the structure receives a memberwise initializer even if it has stored properties that do not have default values.

  The memberwise initializer is a shorthand way to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name.
. Both properties are inferred to be of type .

  Initializers can call other initializers to perform part of an instance's initialization. This process, known as , avoids duplicating code across multiple initializers.

  The rules for how initializer delegation works, and for what forms of delegation are allowed, are different for value types and class types. Value types (structures and enumerations) do not support inheritance, and so their initializer delegation process is relatively simple, because they can only delegate to another initializer that they provide themselves. Classes, however, can inherit from other classes, as described in . This means that classes have additional responsibilities for ensuring that all stored properties they inherit are assigned a suitable value during initialization. These responsibilities are described in  below.
 to refer to other initializers from the same value type when writing your own custom initializers. You can only call  from within an initializer.

  Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise initializer, if it is a structure) for that type. This constraint prevents a situation in which additional essential setup provided in a more complex initializer is circumvented by someone accidentally using one of the automatic initializers instead.
If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type's original implementation. For more information, see .
    	 structure to represent a geometric rectangle. The example requires two supporting structures called  property values, by providing a specific origin point and size, or by providing a specific center point and size. These initialization options are represented by three custom initializers that are part of the , is functionally the same as the default initializer that the structure would have received if it did not have its own custom initializers. This initializer has an empty body, represented by an empty pair of curly braces , and does not perform any initialization. Calling this initializer returns a , is functionally the same as the memberwise initializer that the structure would have received if it did not have its own custom initializers. This initializer simply assigns the , is slightly more complex. It starts by calculating an appropriate origin point based on a  value. It then calls (or  to the appropriate properties itself. However, it is more convenient (and clearer in intent) for the  initializer to take advantage of an existing initializer that already provides exactly that functionality.
.
    	 be assigned an initial value during initialization.

  Swift defines two kinds of initializers for class types to help ensure all stored properties receive an initial value. These are known as designated initializers and convenience initializers.
 are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.

  Classes tend to have very few designated initializers, and it is quite common for a class to have only one. Designated initializers are “funnel” points through which initialization takes place, and through which the initialization process continues up the superclass chain.

  Every class must have at least one designated initializer. In some cases, this requirement is satisfied by inheriting one or more designated initializers from a superclass, as described in  below.
 are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer's parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.

  You do not have to provide convenience initializers if your class does not require them. Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent.

  A designated initializer must call a designated initializer from its immediate superclass.
 class.

  A convenience initializer must ultimately call a designated initializer.
.
.

  Here, the superclass has a single designated initializer and two convenience initializers. One convenience initializer calls another convenience initializer, which in turn calls the single designated initializer. This satisfies rules 2 and 3 from above. The superclass does not itself have a further superclass, and so rule 1 does not apply.

  The subclass in this figure has two designated initializers and one convenience initializer. The convenience initializer must call one of the two designated initializers, because it can only call another initializer from the same class. This satisfies rules 2 and 3 from above. Both designated initializers must call the single designated initializer from the superclass, to satisfy rule 1 from above.
 instances of each class. Any initializer in the diagram above can be used to create a fully-initialized instance of the class they belong to. The rules only affect how you write the class's implementation.
    	
  The figure below shows a more complex class hierarchy for four classes. It illustrates how the designated initializers in this hierarchy act as “funnel” points for class initialization, simplifying the interrelationships among classes in the chain:

  Class initialization in Swift is a two-phase process. In the first phase, each stored property is assigned an initial value by the class that introduced it. Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.

  The use of a two-phase initialization process makes initialization safe, while still giving complete flexibility to each class in a class hierarchy. Two-phase initialization prevents property values from being accessed before they are initialized, and prevents property values from being set to a different value by another initializer unexpectedly.
Swift's two-phase initialization process is similar to initialization in Objective-C. The main difference is that during phase 1, Objective-C assigns zero or null values (such as ) to every property. Swift's initialization flow is more flexible in that it lets you set custom initial values, and can cope with types for which  is not a valid default value.
    	
  A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer.

  As mentioned above, the memory for an object is only considered fully initialized once the initial state of all of its stored properties is known. In order for this rule to be satisfied, a designated initializer must make sure that all its own properties are initialized before it hands off up the chain.

  A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property. If it doesn't, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization.
 property (including properties defined by the same class). If it doesn't, the new value the convenience initializer assigns will be overwritten by its own class's designated initializer.
 as a value until after the first phase of initialization is complete.

  The class instance is not fully valid until the first phase ends. Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.

  A designated or convenience initializer is called on a class.

  Memory for a new instance of that class is allocated. The memory is not yet initialized.

  A designated initializer for that class confirms that all stored properties introduced by that class have a value. The memory for these stored properties is now initialized.

  The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties.

  This continues up the class inheritance chain until the top of the chain is reached.

  Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instance's memory is considered to be fully initialized, and phase 1 is complete.

  Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access  and can modify its properties, call its instance methods, and so on.
.

  In this example, initialization begins with a call to a convenience initializer on the subclass. This convenience initializer cannot yet modify any properties. It delegates across to a designated initializer from the same class.

  The designated initializer makes sure that all of the subclass's properties have a value, as per safety check 1. It then calls a designated initializer on its superclass to continue the initialization up the chain.

  The superclass's designated initializer makes sure that all of the superclass properties have a value. There are no further superclasses to initialize, and so no further delegation is needed.

  As soon as all properties of the superclass have an initial value, its memory is considered fully initialized, and Phase 1 is complete.

  The superclass's designated initializer now has an opportunity to customize the instance further (although it does not have to).

  Once the superclass's designated initializer is finished, the subclass's designated initializer can perform additional customization (although again, it does not have to).

  Finally, once the subclass's designated initializer is finished, the convenience initializer that was originally called can perform additional customization.

  Unlike subclasses in Objective-C, Swift subclasses do not inherit their superclass initializers by default. Swift's approach prevents a situation in which a simple initializer from a superclass is inherited by a more specialized subclass and is used to create a new instance of the subclass that is not fully or correctly initialized.
 inherited in certain circumstances, but only when it is safe and appropriate to do so. For more information, see  below.
    	
  If you want a custom subclass to present one or more of the same initializers as its superclass, you can provide a custom implementation of those initializers within the subclass.
 initializer, you are effectively providing an override of that designated initializer. Therefore, you must write the  modifier before the subclass's initializer definition. This is true even if you are overriding an automatically provided default initializer, as described in .
 modifier prompts Swift to check that the superclass has a matching designated initializer to be overridden, and validates that the parameters for your overriding initializer have been specified as intended.
 modifier when overriding a superclass designated initializer, even if your subclass's implementation of the initializer is a convenience initializer.
    	. Therefore, your subclass is not (strictly speaking) providing an override of the superclass initializer. As a result, you do not write the  modifier when providing a matching implementation of a superclass convenience initializer.
. This base class declares a stored property called . The  class provides a default value for its only stored property, and does not provide any custom initializers itself. As a result, it automatically receives a default initializer, as described in . The default initializer (when available) is always a designated initializer for a class, and can be used to create a new . This designated initializer matches a designated initializer from the superclass of  modifier.
. This ensures that the  has the opportunity to modify the property. After calling .
Subclasses can modify inherited variable properties during initialization, but can not modify inherited constant properties.
    	
  As mentioned above, subclasses do not inherit their superclass initializers by default. However, superclass initializers  automatically inherited if certain conditions are met. In practice, this means that you do not need to write initializer overrides in many common scenarios, and can inherit your superclass initializers with minimal effort whenever it is safe to do so.

  If your subclass doesn't define any designated initializers, it automatically inherits all of its superclass designated initializers.
 of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers.

  These rules apply even if your subclass adds further convenience initializers.
A subclass can implement a superclass designated initializer as a subclass convenience initializer as part of satisfying rule 2.
    	
  The following example shows designated initializers, convenience initializers, and automatic initializer inheritance in action. This example defines a hierarchy of three classes called , and demonstrates how their initializers interact.
, which is a simple class to encapsulate the name of a foodstuff. The . This initializer can be used to create a new  instance are fully initialized. The  to complete its initialization.
, with no arguments. The . The  class models an ingredient in a cooking recipe. It introduces an  instance. This initializer starts by assigning the passed . After doing so, the initializer delegates up to the  class. This process satisfies safety check 1 from  above.
 instance by name alone. This convenience initializer assumes a quantity of  instance that is created without an explicit quantity. The definition of this convenience initializer makes  instances. This convenience initializer simply delegates across to the class's designated initializer, passing in a .
. Because this convenience initializer overrides a designated initializer from its superclass, it must be marked with the ).
 has nonetheless provided an implementation of all of its superclass's designated initializers. Therefore,  automatically inherits all of its superclass's convenience initializers too.
. This initializer is therefore inherited by . The inherited version of  version.
. The  class models a recipe ingredient as it appears in a shopping list.

  Every item in the shopping list starts out as “unpurchased”. To represent this fact, . , because items in a shopping list (as modeled here) always start out unpurchased.
    	 of the designated and convenience initializers from its superclass.
 instances. The type of the array is inferred to be . After the array is created, the name of the  and it is marked as having been purchased. Printing the description of each item in the array shows that their default states have been set as expected.

  It is sometimes useful to define a class, structure, or enumeration for which initialization can fail. This failure might be triggered by invalid initialization parameter values, the absence of a required external resource, or some other condition that prevents initialization from succeeding.
 as part of a class, structure, or enumeration definition. You write a failable initializer by placing a question mark after the ).
You cannot define a failable and a nonfailable initializer with the same parameter types and names.
    	 value of the type it initializes. You write  within a failable initializer to indicate a point at which initialization failure can be triggered.
Strictly speaking, initializers do not return a value. Rather, their role is to ensure that  is fully and correctly initialized by the time that initialization ends. Although you write  keyword to indicate initialization success.
    	. The . This initializer checks if the  value passed to the initializer is an empty string. If an empty string is found, an initialization failure is triggered. Otherwise, the  value. In the example above, an empty string (. However, it is not appropriate for an animal to have an empty string as the value of its  property. To model this restriction, the failable initializer triggers an initialization failure if an empty string is found.
    	
  You can use a failable initializer to select an appropriate enumeration member based on one or more parameters. The initializer can then fail if the provided parameters do not match an appropriate enumeration member.
). A failable initializer is used to find an appropriate enumeration member for a  of the appropriate raw-value type and selects a matching enumeration member if one is found, or triggers an initialization failure if no matching value exists.

  A failable initializer for a value type (that is, a structure or enumeration) can trigger an initialization failure at any point within its initializer implementation. In the  property has been set.
 all stored properties introduced by that class have been set to an initial value and any initializer delegation has taken place.
 structure seen earlier. The  property that must not be allowed to take an empty string value. To enforce this requirement, the  class uses a failable initializer to ensure that the property's value is non-empty before allowing initialization to succeed.
 is a class, not a structure. This means that unlike  triggering an initialization failure.
). Because it is of an optional type, this means that the  before it is assigned a specific value during initialization. This default value of  class have a valid initial value. As a result, the failable initializer for  property within the initializer.
 value if initialization succeeds. Even though it is defined with an implicitly unwrapped optional type, you can always access its implicitly unwrapped value with confidence, without needing to check for a value of 
  A failable initializer of a class, structure, or enumeration can delegate across to another failable initializer from the same class, structure, or enumeration. Similarly, a subclass failable initializer can delegate up to a superclass failable initializer.

  In either case, if you delegate to another initializer that causes initialization to fail, the entire initialization process fails immediately, and no further initialization code is executed.
A failable initializer can also delegate to a nonfailable initializer. Use this approach if you need to add a potential failure state to an existing initialization process that does not otherwise fail.
    	. The  class models an item in an online shopping cart. ). As with the  before it is assigned a specific value during initialization.
. This satisfies the requirement that a failable initializer must always perform initializer delegation before triggering an initialization failure.
 value, the entire initialization process fails immediately and no further initialization code is executed. If the superclass initialization succeeds, the  or more.

  You can override a superclass failable initializer in a subclass, just like any other initializer. Alternatively, you can override a superclass failable initializer with a subclass -failable initializer. This enables you to define a subclass for which initialization cannot fail, even though initialization of the superclass is allowed to fail.

  Note that if you override a failable superclass initializer with a nonfailable subclass initializer, the subclass initializer cannot delegate up to the superclass initializer. A nonfailable initializer can never delegate to a failable initializer.
You can override a failable initializer with a nonfailable initializer but not the other way around.
    	. This class models a document that can be initialized with a . The . These overrides ensure that an  initializer. Because  copes with the empty string case in a different way than its superclass, its initializer does not need to fail, and so it provides a nonfailable version of the initializer instead.
). Alternatively, you can define a failable initializer that creates an implicitly unwrapped optional instance of the appropriate type. Do this by placing an exclamation mark after the ) instead of a question mark.
 and vice versa. You can also delegate from  initializer causes initialization to fail.
 modifier before every subclass implementation of a required initializer, to indicate that the initializer requirement applies to further subclasses in the chain. You do not write the You do not have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initializer.
    	
  If a stored property's default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that property. Whenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the property's default value.

  These kinds of closures or functions typically create a temporary value of the same type as the property, tailor that value to represent the desired initial state, and then return that temporary value to be used as the property's default value.

  Note that the closure's end curly brace is followed by an empty pair of parentheses. This tells Swift to execute the closure immediately. If you omit these parentheses, you are trying to assign the closure itself to the property, and not the return value of the closure.
If you use a closure to initialize a property, remember that the rest of the instance has not yet been initialized at the point that the closure is executed. This means that you cannot access any other property values from within your closure, even if those properties have default values. You also cannot use the implicit  property, or call any of the instance's methods.
    	 is played on a ten-by-ten board, with alternating black and white squares. To represent this game board, the  values. A value of  represents a white square. The first item in the array represents the top left square on the board and the last item in the array represents the bottom right square on the board.
 is calculated and returned. The closure in the example above calculates and sets the appropriate color for each square on the board in a temporary array called , and returns this temporary array as the closure's return value once its setup is complete. The returned array value is stored in Copyright � 2015 Apple Inc. All rights reserved.  is called immediately before a class instance is deallocated. You write deinitializers with the  keyword. Deinitializers are only available on class types.

  Swift automatically deallocates your instances when they are no longer needed, to free up resources. Swift handles the memory management of instances through . Typically you don't need to perform manual clean-up when your instances are deallocated. However, when you are working with your own resources, you might need to perform some additional clean-up yourself. For example, if you create a custom class to open a file and write some data to it, you might need to close the file before the class instance is deallocated.

  Class definitions can have at most one deinitializer per class. The deinitializer does not take any parameters and is written without parentheses:

  Deinitializers are called automatically, just before instance deallocation takes place. You are not allowed to call a deinitializer yourself. Superclass deinitializers are inherited by their subclasses, and the superclass deinitializer is called automatically at the end of a subclass deinitializer implementation. Superclass deinitializers are always called, even if a subclass does not provide its own deinitializer.

  Because an instance is not deallocated until after its deinitializer is called, a deinitializer can access all properties of the instance it is called on and can modify its behavior based on those properties (such as looking up the name of a file that needs to be closed).

  Here's an example of a deinitializer in action. This example defines two new types, , for a simple game. The  structure manages a made-up currency, which can never have more than 10,000 coins in circulation. There can only ever be one  property. It also offers two methods——to handle the distribution and collection of coins.
 checks that there are enough coins in the bank before distributing them. If there are not enough coins,  returns a smaller number than the number that was requested (and returns zero if no coins are left in the bank).  as a variable parameter, so that the number can be modified within the method's body without the need to declare a new variable. It returns an integer value to indicate the actual number of coins that were provided.
 method simply adds the received number of coins back into the bank's coin store.
 class describes a player in the game. Each player has a certain number of coins stored in their purse at any time. This is represented by the player's  instance may receive fewer than that number if not enough coins are available.
 method, which retrieves a certain number of coins from the bank and adds them to the player's purse. The  instance is deallocated. Here, the deinitializer simply returns all of the player's coins to the bank:
 instance is created, with a request for 100 coins if they are available. This . An optional variable is used here, because players can leave the game at any point. The optional lets you track whether there is currently a player in the game.

  Here, the player has won 2,000 coins. The player's purse now contains 2,100 coins, and the bank has only 7,900 coins left.

  The player has now left the game. This is indicated by setting the optional  instance.” At the point that this happens, the  instance is broken. No other properties or variables are still referring to the  instance, and so it is deallocated in order to free up its memory. Just before this happens, its deinitializer is called automatically, and its coins are returned to the bank.
Copyright � 2015 Apple Inc. All rights reserved.  (ARC) to track and manage your app's memory usage. In most cases, this means that memory management “just works” in Swift, and you do not need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.

  However, in a few cases ARC requires more information about the relationships between parts of your code in order to manage memory for you. This chapter describes those situations and shows how you enable ARC to manage all of your app's memory.
Reference counting only applies to instances of classes. Structures and enumerations are value types, not reference types, and are not stored and passed by reference.
    	
  Every time you create a new instance of a class, ARC allocates a chunk of memory to store information about that instance. This memory holds information about the type of the instance, together with the values of any stored properties associated with that instance.

  Additionally, when an instance is no longer needed, ARC frees up the memory used by that instance so that the memory can be used for other purposes instead. This ensures that class instances do not take up space in memory when they are no longer needed.

  However, if ARC were to deallocate an instance that was still in use, it would no longer be possible to access that instance's properties, or call that instance's methods. Indeed, if you tried to access the instance, your app would most likely crash.

  To make sure that instances don't disappear while they are still needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance. ARC will not deallocate an instance as long as at least one active reference to that instance still exists.
 to the instance. The reference is called a “strong“ reference because it keeps a firm hold on that instance, and does not allow it to be deallocated for as long as that strong reference remains.

  Here's an example of how Automatic Reference Counting works. This example starts with a simple class called  property and prints a message to indicate that initialization is underway. The  class also has a deinitializer that prints a message when an instance of the class is deallocated.
 instance in subsequent code snippets. Because these variables are of an optional type ( instance.
 class's initializer. This confirms that initialization has taken place.
 instance. Because there is at least one strong reference, ARC makes sure that this  is kept in memory and is not deallocated.
 instance.
 instance when it is no longer needed.
 gets to a point where it has zero strong references. This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive. This is known as a .

  You resolve strong reference cycles by defining some of the relationships between classes as weak or unowned references instead of as strong references. This process is described in . However, before you learn how to resolve a strong reference cycle, it is useful to understand how such a cycle is caused.

  Here's an example of how a strong reference cycle can be created by accident. This example defines two classes called . The  property is optional, because a person may not always have an apartment.
. The tenant property is optional because an apartment may not always have a tenant.

  Both of these classes also define a deinitializer, which prints the fact that an instance of that class is being deinitialized. This enables you to see whether instances of  are being deallocated as expected.
 instance below. Both of these variables have an initial value of 
  Here's how the strong references look after creating and assigning these two instances. The 
  You can now link the two instances together so that the person has an apartment, and the apartment has a tenant. Note that an exclamation mark (
  Unfortunately, linking these two instances creates a strong reference cycle between them. The  instance. Therefore, when you break the strong references held by the . The strong reference cycle prevents the  instances from ever being deallocated, causing a memory leak in your app.
 instance remain and cannot be broken.

  Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references.
 keeping a strong hold on it. The instances can then refer to each other without creating a strong reference cycle.
 at some point during its lifetime. Conversely, use an unowned reference when you know that the reference will never be  once it has been set during initialization.
 is a reference that does not keep a strong hold on the instance it refers to, and so does not stop ARC from disposing of the referenced instance. This behavior prevents the reference from becoming part of a strong reference cycle. You indicate a weak reference by placing the  keyword before a property or variable declaration.

  Use a weak reference to avoid reference cycles whenever it is possible for that reference to have “no value” at some point in its life. If the reference will . In the  example above, it is appropriate for an apartment to be able to have “no tenant” at some point in its lifetime, and so a weak reference is an appropriate way to break the reference cycle in this case.
Weak references must be declared as variables, to indicate that their value can change at runtime. A weak reference cannot be declared as a constant.
    	
  Because weak references are allowed to have “no value”, you must declare every weak reference as having an optional type. Optional types are the preferred way to represent the possibility for “no value” in Swift.

  Because a weak reference does not keep a strong hold on the instance it refers to, it is possible for that instance to be deallocated while the weak reference is still referring to it. Therefore, ARC automatically sets a weak reference to  when the instance that it refers to is deallocated. You can check for the existence of a value in the weak reference, just like any other optional value, and you will never end up with a reference to an invalid instance that no longer exists.
 example from above, with one important difference. This time around, the  instance. This means that when you break the strong reference held by the  variable. If you break . This proves that the reference cycle has been broken.
 does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is assumed to  have a value. Because of this, an unowned reference is always defined as a non-optional type. You indicate an unowned reference by placing the  keyword before a property or variable declaration.

  Because an unowned reference is non-optional, you don't need to unwrap the unowned reference each time it is used. An unowned reference can always be accessed directly. However, ARC cannot set the reference to .
If you try to access an unowned reference after the instance that it references is deallocated, you will trigger a runtime error. Use unowned references only when you are sure that the reference will  refer to an instance.
    	
  Note also that Swift guarantees your app will crash if you try to access an unowned reference after the instance it references is deallocated. You will never encounter unexpected behavior in this situation. Your app will always crash reliably, although you should, of course, prevent it from doing so.
, which model a bank customer and a possible credit card for that customer. These two classes each store an instance of the other class as a property. This relationship has the potential to create a strong reference cycle.
 seen in the weak reference example above. In this data model, a customer may or may not have a credit card, but a credit card will  be associated with a customer. To represent this, the  property.
 initializer. This ensures that a  instance is created.
 property's capacity is large enough to store a 16-digit card number on both 32-bit and 64-bit systems.
    	, which will be used to store a reference to a specific customer. This variable has an initial value of nil, by virtue of being optional:
 instance.
 instance, it is deallocated. After this happens, there are no more strong references to the .

  The examples for weak and unowned references above cover two of the more common scenarios in which it is necessary to break a strong reference cycle.
, have the potential to cause a strong reference cycle. This scenario is best resolved with a weak reference.
 have the potential to cause a strong reference cycle. This scenario is best resolved with an unowned reference.
 once initialization is complete. In this scenario, it is useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.

  This enables both properties to be accessed directly (without optional unwrapping) once initialization is complete, while still avoiding a reference cycle. This section shows you how to set up such a relationship.
, each of which stores an instance of the other class as a property. In this data model, every country must always have a capital city, and every city must always belong to a country. To represent this, the  property.
. However, the initializer for .
). This means that the .
 property within its initializer. This means that the  property is set. The  property.

  In the example above, the use of an implicitly unwrapped optional means that all of the two-phase class initializer requirements are satisfied. The  property can be used and accessed like a non-optional value once initialization is complete, while still avoiding a strong reference cycle.

  You saw above how a strong reference cycle can be created when two class instance properties hold a strong reference to each other. You also saw how to use weak and unowned references to break these strong reference cycles.

  A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. This capture might occur because the closure's body accesses a property of the instance, such as . In either case, these accesses cause the closure to “capture” , creating a strong reference cycle.
. When you assign a closure to a property, you are assigning a  to that closure. In essence, it's the same problem as above—two strong references are keeping each other alive. However, rather than two class instances, this time it's a class instance and a closure that are keeping each other alive.
. However, before you learn how to break a strong reference cycle with a closure capture list, it is useful to understand how such a cycle can be caused.
. This example defines a class called  for a line break element.  property, which you can set to a string that represents the text to be rendered within that HTML element.
. This property references a closure that combines  into an HTML string fragment. The  value”.
 property is assigned a closure that returns a string representation of an HTML tag. This tag contains the optional  does not exist. For a paragraph element, the closure would return .
 property is named and used somewhat like an instance method. However, because  property with a custom closure, if you want to change the HTML rendering for a particular HTML element.
 property is declared as a lazy property, because it is only needed if and when the element actually needs to be rendered as a string value for some HTML output target. The fact that  is known to exist.
    	 argument to initialize a new element. The class also defines a deinitializer, which prints a message to show when an  instance is deallocated.
 below to demonstrate the presence of a strong reference cycle.
    	 value. Here's how the cycle looks:
 property holds a strong reference to its closure. However, because the closure refers to  instance. A strong reference cycle is created between the two. (For more information about capturing values in a closure, see .)
 instance.
    	 instance is not deallocated.
 as part of the closure's definition. A capture list defines the rules to use when capturing one or more reference types within the closure's body. As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference. The appropriate choice of weak or unowned depends on the relationships between the different parts of your code.
 within a closure. This helps you remember that it's possible to capture  by accident.
    	). These pairings are written within a pair of square braces, separated by commas.

  Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.
 at some point in the future. Weak references are always of an optional type, and automatically become  when the instance they reference is deallocated. This enables you to check for their existence within the closure's body.
, it should always be captured as an unowned reference, rather than a weak reference.
    	 example from earlier. Here's how you write the  closure. In this case, the capture list is , which means “capture self as an unowned reference rather than a strong reference”.
 instance it has captured. If you set the strong reference from the Copyright � 2015 Apple Inc. All rights reserved. . If the optional contains a value, the property, method, or subscript call succeeds; if the optional is . Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is .
 in Objective-C, but in a way that works for any type, and that can be checked for success or failure.
    	. This is very similar to placing an exclamation mark () after an optional value to force the unwrapping of its value. The main difference is that optional chaining fails gracefully when the optional is .
 value, the result of an optional chaining call is always an optional value, even if the property, method, or subscript you are querying returns a non-optional value. You can use this optional return value to check whether the optional chaining call was successful (the returned optional contains a value), or did not succeed due to a ).

  Specifically, the result of an optional chaining call is of the same type as the expected return value, but wrapped in an optional. A property that normally returns an  when accessed through optional chaining.

  The next several code snippets demonstrate how optional chaining differs from forced unwrapping and enables you to check for success.
. .
, by virtue of being optional. In the code below,  value containing the appropriate number of rooms. However, this code always triggers a runtime error when , as illustrated above.
. To use optional chaining, use a question mark in place of the exclamation mark:
 exists.
”. When .
. The fact that it is queried through an optional chain means that the call to .
. If you try to access 
  You can use optional chaining with calls to properties, methods, and subscripts that are more than one level deep. This enables you to drill down into subproperties within complex models of interrelated types, and to check whether it is possible to access properties, methods, and subscripts on those subproperties.

  The code snippets below define four model classes for use in several subsequent examples, including examples of multilevel optional chaining. These classes expand upon the  class, with associated properties, methods, and subscripts.
 class is more complex than before. This time, the  property is implemented as a computed property, not a stored property. The computed  array.
 array.
, which simply prints the number of rooms in the residence.
. The  class type for this property is defined below.
. This class has three optional properties of type . The first two properties, , are alternative ways to identify a particular building as part of an address. The third property, . This method checks the  if neither property has a value.
, you can use optional chaining to access a property on an optional value, and to check if that property access is successful.
, this optional chaining call fails in the same way as before.
.

  You can use optional chaining to call a method on an optional value, and to check whether that method call is successful. You can do this even if that method does not define a return value.
. Here's how the method looks:

  This method does not specify a return type. However, functions and methods with no return type have an implicit return type of . This means that they return a value of , or an empty tuple.
, because return values are always of an optional type when called through optional chaining. This enables you to use an  method, even though the method does not itself define a return value. Compare the return value from the 
  The same is true if you attempt to set a property through optional chaining. The example above in . Any attempt to set a property through optional chaining returns a value of type 
  You can use optional chaining to try to retrieve and set a value from a subscript on an optional value, and to check whether that subscript call is successful.
 the subscript's braces, not after. The optional chaining question mark always follows immediately after the part of the expression that is optional.
    	 class. Because  is the optional value on which optional chaining is being attempted.
.
 values. The example uses optional chaining to set the first item in the . The first two calls succeed, because the . The third call fails, because the .

  You can link together multiple levels of optional chaining to drill down to properties, methods, and subscripts deeper within a model. However, multiple levels of optional chaining do not add more levels of optionality to the returned value.

  If the type you are trying to retrieve is not optional, it will become optional because of the optional chaining.
 optional because of the chaining.
 is always returned, no matter how many levels of chaining are used.
 is always returned, no matter how many levels of chaining are used.
. There are  instance. However, the value of . Because of this, the call to  fails.
 property. The type of this property is . The return value of , even though two levels of optional chaining are applied in addition to the underlying optional type of the property.
. The  property.

  The previous example shows how to retrieve the value of a property of optional type through optional chaining. You can also use optional chaining to call a method that returns a value of optional type, and to chain on that method's return value if needed.
 method through optional chaining. This method returns a value of type . As described above, the ultimate return type of this method call after optional chaining is also  method itself.
    	Copyright � 2015 Apple Inc. All rights reserved.  is a way to check the type of an instance, and/or to treat that instance as if it is a different superclass or subclass from somewhere else in its own class hierarchy.
 operators. These two operators provide a simple and expressive way to check the type of a value or cast a value to a different type.
.

  You can use type casting with a hierarchy of classes and subclasses to check the type of a particular class instance and to cast that instance to another class within the same hierarchy. The three code snippets below define a hierarchy of classes and an array containing instances of those classes, for use in an example of type casting.
. This class provides basic functionality for any kind of item that appears in a digital media library. Specifically, it declares a  initializer. (It is assumed that all media items, including all movies and songs, will have a name.)
. The first subclass, , encapsulates additional information about a movie or film. It adds a  class, with a corresponding initializer. The second subclass,  instances. The type of the  array is inferred by initializing it with the contents of an array literal. Swift's type checker is able to deduce that  instances behind the scenes. However, if you iterate over the contents of this array, the items you receive back are typed as . In order to work with them as their native type, you need to  them to a different type, as described below.
) to check whether an instance is of a certain subclass type. The type check operator returns  if it is not.
 array. On each pass, the  in the array.
 if it is not. Similarly,  instance. At the end of the  instances were found of each type.

  A constant or variable of a certain class type may actually refer to an instance of a subclass behind the scenes. Where you believe this is the case, you can try to ).

  Because downcasting can fail, the type cast operator comes in two different forms. The conditional form, , returns an optional value of the type you are trying to downcast to. The forced form, , attempts the downcast and force-unwraps the result as a single compound action.
) when you are not sure if the downcast will succeed. This form of the operator will always return an optional value, and the value will be  if the downcast was not possible. This enables you to check for a successful downcast.
) only when you are sure that the downcast will always succeed. This form of the operator will trigger a runtime error if you try to downcast to an incorrect class type.
, and prints an appropriate description for each item. To do this, it needs to access each item as a true . This is necessary in order for it to be able to access the  for use in the description.
. You don't know in advance which actual class to use for each item, and so it is appropriate to use the conditional form of the type cast operator (. Because . Because of this uncertainty, the  value when attempting to downcast to a subclass type. The result of ”.
 instances in the library array. To cope with this, the example above uses optional binding to check whether the optional  actually contains a value (that is, to find out whether the downcast succeeded.) This optional binding is written “. If this is successful, set a new temporary constant called .”
. A similar principle is used to check for  is found in the library.
Casting does not actually modify the instance or change its values. The underlying instance remains the same; it is simply treated and accessed as an instance of the type to which it has been cast.
    	 can represent an instance of any class type.
 can represent an instance of any type at all, including function types.
 only when you explicitly need the behavior and capabilities they provide. It is always better to be specific about the types you expect to work with in your code.
    	, or “an array of values of any object type”. This is because Objective-C does not have explicitly typed arrays. However, you can often be confident about the type of objects contained in such an array just from the information you know about the API that provided the array.
, without the need for optional unwrapping.
 to work with a mix of different types, including function types and non-class types. The example creates an array called  value.
. The example below iterates over the items in the  statement. Several of the ) to check and cast to a specific type. This check is always safe within the context of a  case statement.
    	Copyright � 2015 Apple Inc. All rights reserved. 
  Enumerations are often created to support a specific class or structure's functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define , whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.

  To nest a type within another type, write its definition within the outer braces of the type it supports. Types can be nested to as many levels as are required.
, which models a playing card as used in the game of Blackjack. The .

  In Blackjack, the Ace cards have a value of either one or eleven. This feature is represented by a structure called  value to represent their symbol.
 value to represent their face value. (This raw  value is not used for the Jack, Queen, King, and Ace cards.)
. This structure encapsulates the fact that most cards have one value, but the Ace card has two values. The  structure. This computed property considers the rank of the card and initializes a new  instance with appropriate values based on its rank. It uses special values for . For the numeric cards, it uses the rank's raw  value.
. It also defines a computed property called  to build a description of the name and value of the card. The  property uses optional binding to check whether there is a second value to display, and if so, inserts additional description detail for that second value.
. You can use this initializer to initialize a new constant called ) alone. In the example above, the .
 to be kept deliberately short, because their names are naturally qualified by the context in which they are defined.
Copyright � 2015 Apple Inc. All rights reserved.  add new functionality to an existing class, structure, or enumeration type. This includes the ability to extend types for which you do not have access to the original source code (known as ). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions do not have names.)
Extensions can add new functionality to a type, but they cannot override existing functionality.
    	
  An extension can extend an existing type to make it adopt one or more protocols. Where this is the case, the protocol names are written in exactly the same way as for a class or structure:
.
If you define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.
    	
  Extensions can add computed instance properties and computed type properties to existing types. This example adds five computed instance properties to Swift's built-in  value should be considered as a certain unit of length. Although they are implemented as computed properties, the names of these properties can be appended to a floating-point literal value with dot syntax, as a way to use that literal value to perform distance conversions.
 is considered to represent “one meter”. This is why the .

  Other units require some conversion to be expressed as a value measured in meters. One kilometer is the same as 1,000 meters, so the  to convert into a number expressed in meters. Similarly, there are 3.28024 feet in a meter, and so the , to convert it from feet to meters.
 keyword, for brevity. Their return value is of type Extensions can add new computed properties, but they cannot add stored properties, or add property observers to existing properties.
    	
  Extensions can add new initializers to existing types. This enables you to extend other types to accept your own custom types as initializer parameters, or to provide additional initialization options that were not included as part of the type's original implementation.

  Extensions can add new convenience initializers to a class, but they cannot add new designated initializers or deinitializers to a class. Designated initializers and deinitializers must always be provided by the original class implementation.
If you use an extension to add an initializer to a value type that provides default values for all of its stored properties and does not define any custom initializers, you can call the default initializer and memberwise initializer for that value type from within your extension's initializer.
    	.
 structure to represent a geometric rectangle. The example also defines two supporting structures called . These initializers can be used to create new  value. The initializer then calls the structure's automatic memberwise initializer If you provide a new initializer with an extension, you are still responsible for making sure that each instance is fully initialized once the initializer completes.
    	
  Extensions can add new instance methods and type methods to existing types. The following example adds a new instance method called , which indicates a function that has no parameters and does not return a value.
) the instance itself. Structure and enumeration methods that modify , just like mutating methods from an original implementation.

  Extensions can add new subscripts to an existing type. This example adds an integer subscript to Swift's built-in  type. This subscript . This enumeration, called , expresses the kind of number that a particular integer represents. Specifically, it expresses whether the number is negative, zero, or positive.
 enumeration member for that integer.
 values and iterates over those values in turn. For each integer in the array, the function considers the  computed property for that integer, and prints an appropriate description.
. Because of this, all of the .
    	Copyright � 2015 Apple Inc. All rights reserved.  defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol doesn't actually provide an implementation for any of these requirements—it only describes what an implementation will look like. The protocol can then be  by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to  to that protocol.

  Protocols can require that conforming types have specific instance properties, instance methods, type methods, operators, and subscripts.

  Custom types state that they adopt a particular protocol by placing the protocol's name after the type's name, separated by a colon, as part of their definition. Multiple protocols can be listed, and are separated by commas:

  A protocol can require any conforming type to provide an instance property or type property with a particular name and type. The protocol doesn't specify whether the property should be a stored property or a computed property—it only specifies the required property name and type. The protocol also specifies whether each property must be gettable or gettable  settable.

  If a protocol requires a property to be gettable and settable, that property requirement cannot be fulfilled by a constant stored property or a read-only computed property. If the protocol only requires a property to be gettable, the requirement can be satisfied by any kind of property, and it is valid for the property to be also settable if this is useful for your own code.
 keyword. Gettable and settable properties are indicated by writing .
 keyword when you define them in a protocol. This rule pertains even though type property requirements can be prefixed with the  protocol requires a conforming type to provide a fully-qualified name. The protocol doesn't specify anything else about the nature of the conforming type—it only specifies that the type must be able to provide a full name for itself. The protocol states that any .
, which represents a specific named person. It states that it adopts the  protocol as part of the first line of its definition.
. This matches the single requirement of the  has correctly conformed to the protocol. (Swift reports an error at compile-time if a protocol requirement is not fulfilled.)
 property requirement as a computed read-only property for a starship. Each . The  to create a full name for the starship.

  Protocols can require specific instance methods and type methods to be implemented by conforming types. These methods are written as part of the protocol's definition in exactly the same way as for normal instance and type methods, but without curly braces or a method body. Variadic parameters are allowed, subject to the same rules as for normal methods. Default values, however, cannot be specified for method parameters within a protocol's definition.
 keyword when they are defined in a protocol. This is true even though type method requirements are prefixed with the  value whenever it is called. Although it is not specified as part of the protocol, it is assumed that this value will be a number from .
 protocol does not make any assumptions about how each random number will be generated—it simply requires the generator to provide a standard way to generate a new random number.
 protocol. This class implements a pseudorandom number generator algorithm known as a ) the instance it belongs to. For instance methods on value types (that is, structures and enumerations) you place the  keyword to indicate that the method is allowed to modify the instance it belongs to and/or any properties of that instance. This process is described in .
 keyword as part of the protocol's definition. This enables structures and enumerations to adopt the protocol and satisfy that method requirement.
 keyword when writing an implementation of that method for a class. The  keyword is only used by structures and enumerations.
    	. As its name suggests, the  method is intended to toggle or invert the state of any conforming type, typically by modifying a property of that type.
.
. This enumeration toggles between two states, indicated by the enumeration cases . The enumeration's 
  Protocols can require specific initializers to be implemented by conforming types. You write these initializers as part of the protocol's definition in exactly the same way as for normal initializers, but without curly braces or an initializer body:

  You can implement a protocol initializer requirement on a conforming class as either a designated initializer or a convenience initializer. In both cases, you must mark the initializer implementation with the  modifier ensures that you provide an explicit or inherited implementation of the initializer requirement on all subclasses of the conforming class, such that they also conform to the protocol.
.
 modifier, because final classes cannot be subclassed. For more on the .
    	.

  A failable initializer requirement can be satisfied by a failable or nonfailable initializer on a conforming type. A nonfailable initializer requirement can be satisfied by a nonfailable initializer or an implicitly unwrapped failable initializer.

  Protocols do not actually implement any functionality themselves. Nonetheless, any protocol you create will become a fully-fledged type for use in your code.
).
    	-sided dice for use in a board game. , which provides a random number generator from which to create dice roll values.
. Therefore, you can set it to an instance of  protocol. Nothing else is required of the instance you assign to this property, except that the instance must adopt the  protocol.
 also has an initializer, to set up its initial state. This initializer has a parameter called . You can pass a value of any conforming type in to this parameter when initializing a new  instance.
, which returns an integer value between 1 and the number of sides on the dice. This method calls the generator's , and uses this random number to create a dice roll value within the correct range. Because  method to call.
) some of its responsibilities to an instance of another type. This design pattern is implemented by defining a protocol that encapsulates the delegated responsibilities, such that a conforming type (known as a delegate) is guaranteed to provide the functionality that has been delegated. Delegation can be used to respond to a particular action, or to retrieve data from an external source without needing to know the underlying type of that source.
 protocol is a protocol that can be adopted by any game that involves dice. The .
. This version is adapted to use a  chapter.
 protocol. It provides a gettable  method in order to conform to the protocol. (The  property is declared as a constant property because it does not need to change after initialization, and the protocol only requires that it is gettable.)
 initializer. All game logic is moved into the protocol's  property to provide its dice roll values.
, because a delegate isn't required in order to play the game. Because it is of an optional type, the . Thereafter, the game instantiator has the option to set the property to a suitable delegate.
 provides three methods for tracking the progress of a game. These three methods have been incorporated into the game logic within the  method above, and are called when a new game starts, a new turn begins, or the game ends.
 method uses optional chaining each time it calls a method on the delegate. If the  property is nil, these delegate calls fail gracefully and without error. If the  instance as a parameter.
. It uses these methods to keep track of the number of turns a game has taken. It resets a  property to zero when the game starts, increments it each time a new turn begins, and prints out the total number of turns once the game has ended.
 parameter to print some introductory information about the game that is about to be played. The  protocol. However, the method is still able to use type casting to query the type of the underlying instance. In this example, it checks whether  behind the scenes, and prints an appropriate message if so.
 parameter. Because  property, regardless of what kind of game is being played.

  You can extend an existing type to adopt and conform to a new protocol, even if you do not have access to the source code for the existing type. Extensions can add new properties, methods, and subscripts to an existing type, and are therefore able to add any requirements that a protocol may demand. For more about extensions, see .
Existing instances of a type automatically adopt and conform to a protocol when that conformance is added to the instance's type in an extension.
    	, can be implemented by any type that has a way to be represented as text. This might be a description of itself, or a text version of its current state:
 had provided it in its original implementation. The protocol name is provided after the type name, separated by a colon, and an implementation of all requirements of the protocol is provided within the extension's curly braces.
Types do not automatically adopt a protocol just by satisfying its requirements. They must always explicitly declare their adoption of the protocol.
    	. This example creates an array of . It is not of type , even if the actual instance behind the scenes is of one of those types. Nonetheless, because it is of type  each time through the loop.
 one or more other protocols and can add further requirements on top of the requirements it inherits. The syntax for protocol inheritance is similar to the syntax for class inheritance, but with the option to list multiple inherited protocols, separated by commas:
. Anything that adopts . In this example, .
 type. Anything that is  protocol to begin an output string. It appends a colon and a line break, and uses this as the start of its pretty text representation. It then iterates through the array of board squares, and appends a geometric shape to represent the contents of each square:
.
.
.
 keyword to a protocol's inheritance list. The  can only be adopted by class types. It is a compile-time error to write a structure or enumeration definition that tries to adopt .
Use a class-only protocol when the behavior defined by that protocol's requirements assumes or requires that a conforming type has reference semantics rather than value semantics. For more on reference and value semantics, see .
    	
  It can be useful to require a type to conform to multiple protocols at once. You can combine multiple protocols into a single requirement with a . Protocol compositions have the form . You can list as many protocols within the pair of angle brackets () as you need, separated by commas.
. It also defines a protocol called . Both of these protocols are adopted by a structure called .
. The type of this parameter is  protocols.” It doesn't matter what specific type is passed to the function, as long as it conforms to both of the required protocols.
 function. Because  function is able to print its birthday greeting.
Protocol compositions do not define a new, permanent protocol type. Rather, they define a temporary local protocol that has the combined requirements of all protocols in the composition.
    	 to check for protocol conformance, and to cast to a specific protocol. Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a type:
 if it does not.
 if the instance does not conform to that protocol.
 version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast does not succeed.
 property. The  requirement directly as a stored property. Both classes correctly conform to the  protocol.
 classes do not have a shared base class. Nonetheless, they are all classes, and so instances of all three types can be used to initialize an array that stores values of type  instance with four legs.
. The  property can be accessed and printed in a type-safe way.

  Note that the underlying objects are not changed by the casting process. They continue to be a . However, at the point that they are stored in the  property can be accessed.
 for protocols, These requirements do not have to be implemented by types that conform to the protocol. Optional requirements are prefixed by the  modifier as part of the protocol's definition.

  An optional protocol requirement can be called with optional chaining, to account for the possibility that the requirement was not implemented by a type that conforms to the protocol. For information on optional chaining, see .
. Optional property requirements, and optional method requirements that return a value, will always return an optional value of the appropriate type when they are accessed or called, to reflect the fact that the optional requirement may not have been implemented.
 attribute.
    	. Even if you are not interoperating with Objective-C, you need to mark your protocols with the  attribute if you want to specify optional requirements.
 protocols can be adopted only by classes, and not by structures or enumerations. If you mark your protocol as  in order to specify optional requirements, you will only be able to apply that protocol to class types.
, which uses an external data source to provide its increment amount. This data source is defined by the . These requirements define two different ways for data sources to provide an appropriate increment amount for a  instance.
 protocol requirement. They are both optional, after all. Although technically allowed, this wouldn't make for a very good data source.
    	. The  property every time the method is called.
 method on its data source. The  value as the method's single argument.
 levels of optional chaining at play here. Firstly, it is possible that  is non-nil. Secondly, even if , because it is an optional requirement. This is why  is also written with a question mark after its name.
 value. This is true even though .
, using optional binding. If the optional  property, and incrementation is complete.
 property instead. The  property is also an optional requirement, and so its name is also written using optional chaining with a question mark on the end, to indicate that the attempt to access the property's value can fail. As before, the returned value is an optional  protocol definition.
 every time it is queried. It does this by implementing the optional  method four times. As expected, the counter's  is called.
 argument value to work out which direction to count in. If  to indicate that no further counting should take place.
 to zero. Once the counter reaches zero, no more counting takes place:
Copyright � 2015 Apple Inc. All rights reserved.  enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.

  Generics are one of the most powerful features of Swift, and much of the Swift standard library is built with generic code. In fact, you've been using generics throughout the , even if you didn't realize it. For example, Swift's  types are both generic collections. You can create an array that holds  values, or indeed an array for any other type that can be created in Swift. Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be.
.
. You can call this function to swap the values in two  values. If you want to swap two  functions are identical. The only difference is the type of the values that they accept ().
 type. Generic code enables you to write such a function. (A generic version of these functions is defined below.)
 are defined to be the same as each other. If  were not of the same type, it would not be possible to swap their values. Swift is a type-safe language, and does not allow (for example) a variable of type  to swap values with each other. Attempting to do so would be reported as a compile-time error.
    	 can work with any type. Here's a generic version of the  function. However, the first line of . Here's how the first lines compare:
). The placeholder type name doesn't say anything about what  represents. The actual type to use in place of  function is called.
). The brackets tell Swift that  function definition. Because .
 type, as long as both of those values are of the same type as each other. Each time  is inferred from the types of values passed to the function.
, which is part of the Swift standard library, and is automatically made available for you to use in your apps. If you need the behavior of the  function rather than providing your own implementation.
    	. Type parameters specify and name a placeholder type, and are written immediately after the function's name, between a pair of matching angle brackets (such as ).
 function), or as the function's return type, or as a type annotation within the body of the function. In each case, the placeholder type represented by the type parameter is replaced with an  type whenever the function is called. (In the  the second time it was called.)

  You can provide more than one type parameter by writing multiple type parameter names within the angle brackets, separated by commas.
 for the type parameter. However, you can use any valid identifier as the type parameter name.

  If you are defining more complex generic functions, or generic types with multiple parameters, it is useful to provide more descriptive type parameter names. For example, Swift's  type has two type parameters—one for its keys and one for its values. If you were writing  to remind you of their purpose as you use them within your generic code.
, not a value.
    	. These are custom classes, structures, and enumerations that can work with .
. A stack is an ordered set of values, similar to an array, but with a more restricted set of operations than Swift's  type. An array allows new items to be inserted and removed at any location in the array. A stack, however, allows new items to be appended only to the end of the collection (known as  a new value on to the stack). Similarly, a stack allows items to be removed only from the end of the collection (known as  a value off the stack).
 class to model the view controllers in its navigation hierarchy. You call the  method to remove (or pop) a view controller from the navigation stack. A stack is a useful collection model whenever you need a strict “last in, first out” approach to managing a collection.
    	
  There are currently three values on the stack.

  A fourth value is “pushed” on to the top of the stack.

  The stack now holds four values, with the most recent one at the top.

  The top item in the stack is removed, or “popped”.

  After popping a value, the stack once again holds three values.
 to store the values in the stack. , to push and pop values on and off the stack. These methods are marked as  array.
 values, however. It would be much more useful to define a  type of value.
. This type parameter is written within a pair of angle brackets () immediately after the structure's name.
” to be provided later on. This future type can be referred to as “” anywhere within the structure's definition. In this case, .
 instance by writing the type to be stored in the stack within angle brackets. For example, to create a new stack of strings, you write 
  When you extend a generic type, you do not provide a type parameter list as part of the extension's definition. Instead, the type parameter list from the  type definition is available within the body of the extension, and the original type parameter names are used to refer to the type parameters from the original definition.
. If the stack is empty,  array.

  Note that this extension does not define a type parameter list. Instead, the  computed property.
 type can work with any type. However, it is sometimes useful to enforce certain  on the types that can be used with generic functions and generic types. Type constraints specify that a type parameter must inherit from a specific class, or conform to a particular protocol or protocol composition.
 type places a limitation on the types that can be used as keys for a dictionary. As described in . That is, it must provide a way to make itself uniquely representable.  needs its keys to be hashable so that it can check whether it already contains a value for a particular key. Without this requirement,  could not tell whether it should insert or replace a value for a particular key, nor would it be able to find a value for a given key that is already in the dictionary.
 protocol, a special protocol defined in the Swift standard library. All of Swift's basic types (such as ) are hashable by default.

  You can define your own type constraints when creating custom generic types, and these constraints provide much of the power of generic programming. Abstract concepts like  characterize types in terms of their conceptual characteristics, rather than their explicit type.

  You write type constraints by placing a single class or protocol constraint after a type parameter's name, separated by a colon, as part of the type parameter list. The basic syntax for type constraints on a generic function is shown below (although the syntax is the same for generic types):

  The hypothetical function above has two type parameters. The first type parameter, . The second type parameter, .
 values within which to find it. The 
  The principle of finding the index of a value in an array isn't useful only for strings, however. You can write the same functionality as a generic function called  instead.
, to be written. Note that the return type of this function is still , because the function returns an optional index number, not an optional value from the array. Be warned, though—this function does not compile, for reasons explained after the example:

  This function does not compile as written above. The problem lies with the equality check, “”. Not every type in Swift can be compared with the equal to operator (). If you create your own class or structure to represent a complex data model, for example, then the meaning of “equal to” for that class or structure is not something that Swift can guess for you. Because of this, it is not possible to guarantee that this code will work for , and an appropriate error is reported when you try to compile the code.

  All is not lost, however. The Swift standard library defines a protocol called ) to compare any two values of that type. All of Swift's standard types automatically support the  protocol.
 function, because it is guaranteed to support the equal to operator. To express this fact, you write a type constraint of  protocol.”
 as part of the protocol's definition. An associated type gives a placeholder name (or ) to a type that is used as part of the protocol. The actual type to use for that associated type is not specified until the protocol is adopted. Associated types are specified with the  keyword.
 method.
 value.
 index value.

  This protocol doesn't specify how the items in the container should be stored or what type they are allowed to be. The protocol only specifies the three bits of functionality that any type must provide in order to be considered a . A conforming type can provide additional functionality, as long as it satisfies these three requirements.
 protocol must be able to specify the type of values it stores. Specifically, it must ensure that only items of the right type are added to the container, and it must be clear about the type of the items returned by its subscript.
 protocol needs a way to refer to the type of the elements that a container will hold, without knowing what that type is for a specific container. The  method must have the same type as the container's element type, and that the value returned by the container's subscript will be of the same type as the container's element type.
. The protocol does not define what —that information is left for any conforming type to provide. Nonetheless, the  is enforced.
 type's existing functionality to satisfy these requirements.
. The definition of  protocol.
. Because  parameter and the return type of the subscript. Indeed, if you delete the .
 parameter and the return type of the subscript. Swift can therefore infer that  for this particular container.
. This includes a protocol with an associated type.
 index to retrieve its elements. These three capabilities match the requirements of the  protocol. This means that you can extend  adopts the protocol. You do this with an empty extension, as described in  type above. After defining this extension, you can use any .
, enable you to define requirements on the type parameters associated with a generic function or type.

  It can also be useful to define requirements for associated types. You do this by defining  as part of a type parameter list. A where clause enables you to require that an associated type conforms to a certain protocol, and/or that certain type parameters and associated types be the same. You write a where clause by placing the  keyword immediately after the list of type parameters, followed by one or more constraints for associated types, and/or one or more equality relationships between types and associated types.
 instances contain the same items in the same order. The function returns a Boolean value of  if they do not.

  The two containers to be checked do not have to be the same type of container (although they can be), but they do have to hold the same type of items. This requirement is expressed through a combination of type constraints and where clauses:
. The . Both  are placeholder type parameters for two container types to be determined when the function is called.
).
).
).
).
 keyword as part of the function's type parameter list.
.
.
 contain the same type of items.
) to see if they are different from each other.
.
 function to compare the two containers, even if they are of a different container type.
 function starts by checking that both containers contain the same number of items. If they contain a different number of items, there is no way that they can match, and the function returns .
). For each item, the function checks whether the item from . If the two items are not equal, then the two containers do not match, and the function returns .
.
 values, and pushes three strings onto the stack. The example also creates an  instance initialized with an array literal containing the same three strings as the stack. Even though the stack and the array are of a different type, they both conform to the  protocol, and both contain the same type of values. You can therefore call the  function with these two containers as its arguments. In the example above, the  function correctly reports that all of the items in the two containers match.
Copyright � 2015 Apple Inc. All rights reserved.  restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.

  You can assign specific access levels to individual types (classes, structures, and enumerations), as well as to properties, methods, initializers, and subscripts belonging to those types. Protocols can be restricted to a certain context, as can global constants, variables, and functions.

  In addition to offering various levels of access control, Swift reduces the need to specify explicit access control levels by providing default access levels for typical scenarios. Indeed, if you are writing a single-target app, you may not need to specify explicit access control levels at all.
The various aspects of your code that can have access control applied to them (properties, types, functions, and so on) are referred to as “entities” in the sections below, for brevity.
    	
  Swift's access control model is based on the concept of modules and source files.
 keyword.

  Each build target (such as an app bundle or framework) in Xcode is treated as a separate module in Swift. If you group together aspects of your app's code as a stand-alone framework—perhaps to encapsulate and reuse that code across multiple applications—then everything you define within that framework will be part of a separate module when it is imported and used within an app, or when it is used within another framework.
 is a single Swift source code file within a module (in effect, a single file within an app or framework). Although it is common to define individual types in separate source files, a single source file can contain definitions for multiple types, functions, and so on.
 for entities within your code. These access levels are relative to the source file in which an entity is defined, and also relative to the module that source file belongs to.
 enables entities to be used within any source file from their defining module, and also in a source file from another module that imports the defining module. You typically use public access when specifying the public interface to a framework.
 enables entities to be used within any source file from their defining module, but not in any source file outside of that module. You typically use internal access when defining an app's or a framework's internal structure.
 restricts the use of an entity to its own defining source file. Use private access to hide the implementation details of a specific piece of functionality.

  Public access is the highest (least restrictive) access level and private access is the lowest (or most restrictive) access level.

  A public variable cannot be defined as having an internal or private type, because the type might not be available everywhere that the public variable is used.

  A function cannot have a higher access level than its parameter types and return type, because the function could be used in situations where its constituent types are not available to the surrounding code.

  The specific implications of this guiding principle for different aspects of the language are covered in detail below.

  All entities in your code (with a few specific exceptions, as described later in this chapter) have a default access level of internal if you do not specify an explicit access level yourself. As a result, in many cases you do not need to specify an explicit access level in your code.

  When you write a simple single-target app, the code in your app is typically self-contained within the app and does not need to be made available outside of the app's module. The default access level of internal already matches this requirement. Therefore, you do not need to specify a custom access level. You may, however, want to mark some parts of your code as private in order to hide their implementation details from other code within the app's module.

  When you develop a framework, mark the public-facing interface to that framework as public so that it can be viewed and accessed by other modules, such as an app that imports the framework. This public-facing interface is the application programming interface (or API) for the framework.
Any internal implementation details of your framework can still use the default access level of internal, or can be marked as private if you want to hide them from other parts of the framework's internal code. You need to mark an entity as public only if you want it to become part of your framework's API.
    	. This means that 
  If you want to specify an explicit access level for a custom type, do so at the point that you define the type. The new type can then be used wherever its access level permits. For example, if you define a private class, that class can only be used as the type of a property, or as a function parameter or return type, in the source file in which the private class is defined.
 (its properties, methods, initializers, and subscripts). If you define a type's access level as private, the default access level of its members will also be private. If you define a type's access level as internal or public (or use the default access level of internal without specifying an access level explicitly), the default access level of the type's members will be internal.
As mentioned above, a public type defaults to having internal members, not public members. If you want a type member to be public, you must explicitly mark it as such. This requirement ensures that the public-facing API for a type is something you opt in to publishing, and avoids presenting the internal workings of a type as public API by mistake.
    	
  The access level for a tuple type is the most restrictive access level of all types used in that tuple. For example, if you compose a tuple from two different types, one with internal access and one with private access, the access level for that compound tuple type will be private.
Tuple types do not have a standalone definition in the way that classes, structures, enumerations, and functions do. A tuple type's access level is deduced automatically when the tuple type is used, and cannot be specified explicitly.
    	
  The access level for a function type is calculated as the most restrictive access level of the function's parameter types and return type. You must specify the access level explicitly as part of the function's definition if the function's calculated access level does not match the contextual default.
, without providing a specific access level modifier for the function itself. You might expect this function to have the default access level of “internal”, but this is not the case. In fact, . One of these classes was defined as “internal”, and the other was defined as “private”. Therefore, the overall access level of the compound tuple type is “private” (the minimum access level of the tuple's constituent types).
 modifiers, or to use the default setting of internal, because public or internal users of the function might not have appropriate access to the private class used in the function's return type.

  The individual cases of an enumeration automatically receive the same access level as the enumeration they belong to. You cannot specify a different access level for individual enumeration cases.
 enumeration has an explicit access level of “public”. The enumeration cases 
  The types used for any raw values or associated values in an enumeration definition must have an access level at least as high as the enumeration's access level. You cannot use a  access level, for example.

  Nested types defined within a private type have an automatic access level of private. Nested types defined within a public type or an internal type have an automatic access level of internal. If you want a nested type within a public type to be publicly available, you must explicitly declare the nested type as public.

  You can subclass any class that can be accessed in the current access context. A subclass cannot have a higher access level than its superclass—for example, you cannot write a public subclass of an internal superclass.

  In addition, you can override any class member (method, property, initializer, or subscript) that is visible in a certain access context.

  An override can make an inherited class member more accessible than its superclass version. In the example below, class . Class , with a reduced access level of “internal”. Nonetheless, class .

  A constant, variable, or property cannot be more public than its type. It is not valid to write a public property with a private type, for example. Similarly, a subscript cannot be more public than either its index type or return type.

  Getters and setters for constants, variables, properties, and subscripts automatically receive the same access level as the constant, variable, property, or subscript they belong to.
 access level than its corresponding getter, to restrict the read-write scope of that variable, property, or subscript. You assign a lower access level by writing  introducer.
This rule applies to stored properties as well as computed properties. Even though you do not write an explicit getter and setter for a stored property, Swift still synthesizes an implicit getter and setter for you to provide access to the stored property's backing storage. Use  to change the access level of this synthesized setter in exactly the same way as for an explicit setter in a computed property.
    	 (an empty string). The structure also defines a stored integer property called  is modified. This modification tracking is implemented with a  property is set to a new value.
 property do not provide an explicit access level modifier, and so they both receive the default access level of internal. However, the access level for the  structure's definition. The property's getter still has the default access level of internal, but its setter is now private to the source file in which  is defined. This enables  property internally, but to present the property as a read-only property when it is used by other source files within the same module.
 the property from another source file. This restriction protects the implementation details of the  edit-tracking functionality, while still providing convenient access to an aspect of that functionality.

  Note that you can assign an explicit access level for both a getter and a setter if required. The example below shows a version of the  structure in which the structure is defined with an explicit access level of public. The structure's members (including the  property) therefore have an internal access level by default. You can make the structure's 
  Custom initializers can be assigned an access level less than or equal to the type that they initialize. The only exception is for required initializers (as defined in ). A required initializer must have the same access level as the class it belongs to.

  As with function and method parameters, the types of an initializer's parameters cannot be more private than the initializer's own access level.
 without any arguments for any structure or base class that provides default values for all of its properties and does not provide at least one initializer itself.
. For a type that is defined as , the default initializer is considered internal. If you want a public type to be initializable with a no-argument initializer when used in another module, you must explicitly provide a public no-argument initializer yourself as part of the type's definition.

  The default memberwise initializer for a structure type is considered private if any of the structure's stored properties are private. Otherwise, the initializer has an access level of internal.

  As with the default initializer above, if you want a public structure type to be initializable with a memberwise initializer when used in another module, you must provide a public memberwise initializer yourself as part of the type's definition.

  If you want to assign an explicit access level to a protocol type, do so at the point that you define the protocol. This enables you to create protocols that can only be adopted within a certain access context.

  The access level of each requirement within a protocol definition is automatically set to the same access level as the protocol. You cannot set a protocol requirement to a different access level than the protocol it supports. This ensures that all of the protocol's requirements will be visible on any type that adopts the protocol.
If you define a public protocol, the protocol's requirements require a public access level for those requirements when they are implemented. This behavior is different from other types, where a public type definition implies an access level of internal for the type's members.
    	
  If you define a new protocol that inherits from an existing protocol, the new protocol can have at most the same access level as the protocol it inherits from. You cannot write a public protocol that inherits from an internal protocol, for example.

  A type can conform to a protocol with a lower access level than the type itself. For example, you can define a public type that can be used in other modules, but whose conformance to an internal protocol can only be used within the internal protocol's defining module.

  The context in which a type conforms to a particular protocol is the minimum of the type's access level and the protocol's access level. If a type is public, but a protocol it conforms to is internal, the type's conformance to that protocol is also internal.

  When you write or extend a type to conform to a protocol, you must ensure that the type's implementation of each protocol requirement has at least the same access level as the type's conformance to that protocol. For example, if a public type conforms to an internal protocol, the type's implementation of each protocol requirement must be at least “internal”.
In Swift, as in Objective-C, protocol conformance is global—it is not possible for a type to conform to a protocol in two different ways within the same program.
    	
  You can extend a class, structure, or enumeration in any access context in which the class, structure, or enumeration is available. Any type members added in an extension have the same default access level as type members declared in the original type being extended. If you extend a public or internal type, any new type members you add will have a default access level of internal. If you extend a private type, any new type members you add will have a default access level of private.
) to set a new default access level for all members defined within the extension. This new default can still be overridden within the extension for individual type members.

  You cannot provide an explicit access level modifier for an extension if you are using that extension to add protocol conformance. Instead, the protocol's own access level is used to provide the default access level for each protocol requirement implementation within the extension.

  The access level for a generic type or generic function is the minimum of the access level of the generic type or function itself and the access level of any type constraints on its type parameters.

  Any type aliases you define are treated as distinct types for the purposes of access control. A type alias can have an access level less than or equal to the access level of the type it aliases. For example, a private type alias can alias a private, internal, or public type, but a public type alias cannot alias an internal or private type.
This rule also applies to type aliases for associated types used to satisfy protocol conformances.
    	Copyright � 2015 Apple Inc. All rights reserved. , Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.

  Unlike arithmetic operators in C, arithmetic operators in Swift do not overflow by default. Overflow behavior is trapped and reported as an error. To opt in to overflow behavior, use Swift's second set of arithmetic operators that overflow by default, such as the overflow addition operator (). All of these overflow operators begin with an ampersand ().

  When you define your own structures, classes, and enumerations, it can be useful to provide your own implementations of the standard Swift operators for these custom types. Swift makes it easy to provide tailored implementations of these operators and to determine exactly what their behavior should be for each type you create.

  You're not limited to the predefined operators. Swift gives you the freedom to define your own custom infix, prefix, postfix, and assignment operators, with custom precedence and associativity values. These operators can be used and adopted in your code like any of the predefined operators, and you can even extend existing types to support the custom operators you define.
 enable you to manipulate the individual raw data bits within a data structure. They are often used in low-level programming, such as graphics programming and device driver creation. Bitwise operators can also be useful when you work with raw data from external sources, such as encoding and decoding data for communication over a custom protocol.

  Swift supports all of the bitwise operators found in C, as described below.
. This example initializes a . This is equivalent to a decimal value of .
, but with all of the bits inverted. Zeroes become ones, and ones become zeroes. The value of .
) combines the bits of two numbers. It returns a new number whose bits are set to . The bitwise AND operator combines them to make the number ) compares the bits of two numbers. The operator returns a new number whose bits are set to . The bitwise OR operator combines them to make the number ), compares the bits of two numbers. The operator returns a new number whose bits are set to  in a location that the other does not. The bitwise XOR operator sets both of these bits to  in its output value. All of the other bits in ) move all bits in a number to the left or the right by a certain number of places, according to the rules defined below.

  Bitwise left and right shifts have the effect of multiplying or dividing an integer number by a factor of two. Shifting an integer's bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value.

  Existing bits are moved to the left or right by the requested number of places.

  Any bits that are moved beyond the bounds of the integer's storage are discarded.

  Zeroes are inserted in the spaces left behind after the original bits are moved to the left or right.
.
 place). Blue numbers are shifted, gray numbers are discarded, and orange zeroes are inserted:
 to store a Cascading Style Sheets color value for the color pink. The CSS color value  in Swift's hexadecimal number representation. This color is then decomposed into its red ().
. The zeroes in  as the result.
). Each pair of characters in a hexadecimal number uses 8 bits, so a move 16 places to the right will convert . This is the same as .
. This output value is then shifted eight places to the right, giving a value of .
. There's no need to shift this to the right, as .

  The shifting behavior is more complex for signed integers than for unsigned integers, because of the way signed integers are represented in binary. (The examples below are based on 8-bit signed integers for simplicity, but the same principles apply for signed integers of any size.)
) to indicate whether the integer is positive or negative. A sign bit of  means negative.
) store the actual value. Positive numbers are stored in exactly the same way as for unsigned integers, counting upwards from . Here's how the bits inside an , written in binary notation.

  Negative numbers, however, are stored differently. They are stored by subtracting their absolute value from  is the number of value bits. An eight-bit number has seven value bits, so this means .
 representation. It may seem an unusual way to represent negative numbers, but it has several advantages.

  Second, the two's complement representation also lets you shift the bits of negative numbers to the left and right like positive numbers, and still end up doubling them for every shift you make to the left, or halving them for every shift you make to the right. To achieve this, an extra rule is used when signed integers are shifted to the right:
, rather than with a zero.
.

  Because of the special way that positive and negative numbers are stored, shifting either of them to the right moves them closer to zero. Keeping the sign bit the same during this shift means that negative integers remain negative as their value moves closer to zero.

  If you try to insert a number into an integer constant or variable that cannot hold that value, by default Swift reports an error rather than allowing an invalid value to be created. This behavior gives extra safety when you work with numbers that are too large or too small.
. Trying to set an 
  Providing error handling when values get too large or too small gives you much more flexibility when coding for boundary value conditions.

  However, when you specifically want an overflow condition to truncate the number of available bits, you can opt in to this behavior rather than triggering an error. Swift provides three arithmetic  that opt in to the overflow behavior for integer calculations. These operators all begin with an ampersand (
  Numbers can overflow in both the positive and negative direction.
 in binary). It is then incremented by ). This pushes its binary representation just over the size that a  can hold, causing it to overflow beyond its bounds, as shown in the diagram below. The value that remains within the bounds of the , or zero.

  Something similar happens when an unsigned integer is allowed to overflow in the negative direction. Here's an example using the overflow subtraction operator ( in binary. If you subtract  in decimal.

  Overflow also occurs for signed integers. All addition and subtraction for signed integers is performed in bitwise fashion, with the sign bit included as part of the numbers being added or subtracted, as described in .
 in binary. Subtracting  can hold.

  For both signed and unsigned integers, overflow in the positive direction wraps around from the maximum valid integer value back to the minimum, and overflow in the negative direction wraps around from the minimum value to the maximum.
 gives some operators higher priority than others; these operators are applied first.
)—either grouped from the left, or grouped from the right. Think of it as meaning “they associate with the expression to their left,” or “they associate with the expression to their right.”

  It is important to consider each operator's precedence and associativity when working out the order in which a compound expression will be calculated. Here's an example. Why does the following expression equal . Higher-precedence operators are evaluated before lower-precedence ones. In Swift, as in C, the multiplication operator (). As a result, they are both evaluated before the addition is considered.
 precedence as each other. To work out the exact evaluation order to use, you also need to consider their associativity. Multiplication and remainder both associate with the expression to their left. Think of this as adding implicit parentheses around these parts of the expression, starting from their left:
.
.
Swift's operator precedences and associativity rules are simpler and more predictable than those found in C and Objective-C. However, this means that they are not the same as in C-based languages. Be careful to ensure that operator interactions still behave in the way you intend when porting existing code to Swift.
    	
  Classes and structures can provide their own implementations of existing operators. This is known as  the existing operators.
) for a custom structure. The arithmetic addition operator is a  because it appears in between those two targets.
). Because the arithmetic addition operator is a binary operator, this operator function takes two input parameters of type .
 operator. The function returns a new  instances that are added together.
, as illustrated below.

  The example shown above demonstrates a custom implementation of a binary infix operator. Classes and structures can also provide implementations of the standard . Unary operators operate on a single target. They are ).
 instances. The unary minus operator is a prefix operator, and so this function has to be qualified with the  modifier.

  For simple numeric values, the unary minus operator converts positive numbers into their negative equivalent and vice versa. The corresponding implementation for ) with another operation. For example, the addition assignment operator () combines addition and assignment into a single operation. You mark a compound assignment operator's left input parameter as , because the parameter's value will be modified directly from within the operator function.

  Because an addition operator was defined earlier, you don't need to reimplement the addition process here. Instead, the addition assignment operator function takes advantage of the existing addition operator function, and uses it to set the left value to be the left value plus the right value:

  The prefix increment operator function above takes advantage of the addition assignment operator defined earlier. It adds a ). Only the compound assignment operators can be overloaded. Similarly, the ternary conditional operator () cannot be overloaded.
    	). It is not possible for Swift to guess what would qualify as “equal” for your own custom types, because the meaning of “equal” depends on the roles that those types play in your code.
 instances have equivalent values. In the context of  values”, and so this is the logic used by the operator implementation. The example also implements the “not equal to” operator (), which simply returns the inverse of the result of the “equal to” operator.
 in addition to the standard operators provided by Swift. For a list of characters that can be used to define custom operators, see .
. This operator does not have an existing meaning in Swift, and so it is given its own custom meaning below in the specific context of working with  instances. For the purposes of this example,  is treated as a new “prefix doubling incrementer” operator. It doubles the . See  for an explanation of how these two characteristics affect an infix operator's interaction with other infix operators.
. Left-associative operators associate to the left if written next to other left-associative operators of the same precedence. Similarly, right-associative operators associate to the right if written next to other right-associative operators of the same precedence. Non-associative operators cannot be written next to other operators with the same precedence.
 if it is not specified. The  if it is not specified.
 value of the second vector from the first. Because it is in essence an “additive” operator, it has been given the same associativity and precedence values (. For a complete list of the default Swift operator precedence and associativity settings, see .
You do not specify a precedence when defining a prefix or postfix operator. However, if you apply both a prefix and a postfix operator to the same operand, the postfix operator is applied first.
    	Copyright � 2015 Apple Inc. All rights reserved. 
  This part of the book describes the formal grammar of the Swift programming language. The grammar described here is intended to help you understand the language in more detail, rather than to allow you to directly implement a parser or compiler.

  The Swift language is relatively small, because many common types, functions, and operators that appear virtually everywhere in Swift code are actually defined in the Swift standard library. Although these types, functions, and operators are not part of the Swift language itself, they are used extensively in the discussions and code examples in this part of the book.

  An arrow (→) is used to mark grammar productions and can be read as “can consist of.”
 text and appear on both sides of a grammar production rule.
 text and appear only on the right-hand side of a grammar production rule.

  Alternative grammar productions are separated by vertical bars (|). When alternative productions are too long to read easily, they are broken into multiple grammar production rules on new lines.

  In a few cases, regular font text is used to describe the right-hand side of a grammar production rule.
.
 a setter clause followed by a getter clause, enclosed in braces. The grammar production above is equivalent to the following two productions, where the alternatives are spelled out explicitly:
Copyright � 2015 Apple Inc. All rights reserved.  of Swift describes what sequence of characters form valid tokens of the language. These valid tokens form the lowest-level building blocks of the language and are used to describe the rest of the language in subsequent chapters. A token consists of an identifier, keyword, punctuation, literal, or operator.

  In most cases, tokens are generated from the characters of a Swift source file by considering the longest possible substring from the input text, within the constraints of the grammar that are specified below. This behavior is referred to as .
), but is otherwise ignored. The following characters are considered whitespace: space (U+0020), line feed (U+000A), carriage return (U+000D), horizontal tab (U+0009), vertical tab (U+000B), form feed (U+000C) and null (U+0000).

  Comments are treated as whitespace by the compiler. Single line comments begin with  and continue until a line feed (U+000A) or carriage return (U+000D). Multiline comments begin with . Nesting multiline comments is allowed, but the comment markers must be balanced.
), a noncombining alphanumeric Unicode character in the Basic Multilingual Plane, or a character outside the Basic Multilingual Plane that isn't in a Private Use Area. After the first character, digits and combining Unicode characters are also allowed.
) before and after it. For example,  is valid. The backticks are not considered part of the identifier;  have the same meaning.
, and so on. These names are valid identifiers within the scope of the closure.
.
.
.
.
. Outside the context in which they appear in the grammar, they can be used as identifiers.
 (as a postfix operator).
 is the source code representation of a value of a type, such as a number or string.

  A literal doesn't have a type on its own. Instead, a literal is parsed as having infinite precision and Swift's type inference attempts to infer a type for the literal. For example, in the declaration . If there isn't suitable type information available, Swift infers that the literal's type is one of the default literal types defined in the Swift standard library. The default types are  for Boolean literals. For example, in the declaration .

  When specifying the type annotation for a literal value, the annotation's type must be a type that can be instantiated from that literal value. That is, the type must conform to one of the following Swift standard library protocols:  for Boolean literals. For example, .
 represent integer values of unspecified precision. By default, integer literals are expressed in decimal; you can specify an alternate base using a prefix. Binary literals begin with .
. Binary literals contain  in upper- or lowercase.
.
) are allowed between digits for readability, but they are ignored and therefore don't affect the value of the literal. Integer literals can begin with leading zeros (), but they are likewise ignored and don't affect the base or value of the literal.
. The Swift standard library also defines types for various sizes of signed and unsigned integers, as described in .
 represent floating-point values of unspecified precision.
 prefix).

  Decimal floating-point literals consist of a sequence of decimal digits followed by either a decimal fraction, a decimal exponent, or both. The decimal fraction consists of a decimal point () followed by a sequence of decimal digits. The exponent consists of an upper- or lowercase  is multiplied by. For example,  represents 1.25 x 10. Similarly,  represents 1.25 x 10.
 prefix, followed by an optional hexadecimal fraction, followed by a hexadecimal exponent. The hexadecimal fraction consists of a decimal point followed by a sequence of hexadecimal digits. The exponent consists of an upper- or lowercase  is multiplied by. For example, . Similarly, .
.
) are allowed between digits for readability, but are ignored and therefore don't affect the value of the literal. Floating-point literals can begin with leading zeros (), but are likewise ignored and don't affect the base or value of the literal.
, which represents a 64-bit floating-point number. The Swift standard library also defines a  type, which represents a 32-bit floating-point number.
), a carriage return, or a line feed.
). The interpolated expression must not contain an unescaped double quote (), a carriage return, or a line feed. The expression must evaluate to a value of a type that the  class has an initializer for.
. The default inferred type of the characters that make up a string is . For more information about the .
. The present section describes which characters can be used to define custom operators.
 Unicode blocks, among others). After the first character, combining Unicode characters are also allowed. You can also define custom operators as a sequence of two or more dots (for example, ). Although you can define custom operators that contain a question mark character (), they can't consist of a single question mark character only.
 are reserved. These tokens can't be overloaded, nor can they be used as custom operators.
    	
  The whitespace around an operator is used to determine whether an operator is used as a prefix operator, a postfix operator, or a binary operator. This behavior is summarized in the following rules:

  If an operator has whitespace around both sides or around neither side, it is treated as a binary operator. As an example, the  is treated as a binary operator.

  If an operator has whitespace on the left side only, it is treated as a prefix unary operator. As an example, the  is treated as a prefix unary operator.

  If an operator has whitespace on the right side only, it is treated as a postfix unary operator. As an example, the  is treated as a postfix unary operator.
), it is treated as a postfix unary operator. As an example, the ).
 are also considered whitespace.

  There is one caveat to the rules above. If the  predefined operator has no whitespace on the left, it is treated as a postfix operator, regardless of whether it has whitespace on the right. To use the  as the optional-chaining operator, it must not have whitespace on the left. To use it in the ternary conditional () operator, it must have whitespace around both sides.
 may be split into two or more tokens. The remainder is treated the same way and may be split again. As a result, there is no need to use whitespace to disambiguate between the closing . In this example, the closing  operator.
. To learn how to overload existing operators, see .
Copyright � 2015 Apple Inc. All rights reserved. 
  In Swift, there are two kinds of types: named types and compound types. A  is a type that can be given a particular name when it is defined. Named types include classes, structures, enumerations, and protocols. For example, instances of a user-defined class named . In addition to user-defined named types, the Swift standard library defines many commonly used named types, including those that represent arrays, dictionaries, and optional values.

  Data types that are normally considered basic or primitive in other languages—such as types that represent numbers, characters, and strings—are actually named types, defined and implemented in the Swift standard library using structures. Because they are named types, you can extend their behavior to suit the needs of your program, using an extension declaration, discussed in .
 is a type without a name, defined in the Swift language itself. There are two compound types: function types and tuple types. A compound type may contain named types and other compound types. For instance, the tuple type .

  This chapter discusses the types defined in the Swift language itself and describes the type inference behavior of Swift.
 explicitly specifies the type of a variable or expression. Type annotations begin with a colon (. In the second example, the parameter .

  Type annotations can contain an optional list of type attributes before the type.

  A type identifier refers to either a named type or a type alias of a named or compound type.

  Most of the time, a type identifier directly refers to a named type with the same name as the identifier. For example, .

  There are two cases in which a type identifier does not refer to a type with the same name. In the first case, a type identifier refers to a type alias of a named or compound type. For instance, in the example below, the use of .
) syntax to refer to named types declared in other modules or nested within other types. For example, the type identifier in the following code references the named type  module.

  A tuple type is a comma-separated list of zero or more types, enclosed in parentheses.

  You can use a tuple type as the return type of a function to enable the function to return a single tuple containing multiple values. You can also name the elements of a tuple type and use those names to refer to the values of the individual elements. An element name consists of an identifier followed immediately by a colon (:). For an example that demonstrates both of these features, see .
. If there is only one element inside the parentheses, the type is simply the type of that element. For example, the type of . As a result, you can name a tuple element only when the tuple type has two or more elements.
 can be a tuple type, function types support functions and methods that take multiple parameters and return multiple values.
). An autoclosure function captures an implicit closure over the specified expression, instead of the expression itself. The following example uses the . Syntactically, a variadic parameter consists of a base type name followed immediately by three dots (. A variadic parameter is treated as an array that contains elements of the base type name. For instance, the variadic parameter . For an example that uses a variadic parameter, see .
 keyword. You can't mark a variadic parameter or a return type with the  keyword. In-out parameters are discussed in .

  The function types of a curried function are grouped from right to left. For instance, the function type . Curried function are described in .
 is declared as an array of strings. The elements of an array can be accessed through subscripting by specifying a valid index value in square brackets: .

  You can create multidimensional arrays by nesting pairs of square brackets, where the name of the base type of the elements is contained in the innermost pair of square brackets. For example, you can create a three-dimensional array of integers using three sets of square brackets:

  When accessing the elements in a multidimensional array, the left-most subscript index refers to the element at that index in the outermost array. The next subscript index to the right refers to the element at that index in the array that's nested one level in. And so on. This means that in the example above,  refers to the value 4.
.
 is declared as a dictionary with strings as keys and integers as values.
. The subscript returns an optional value of the dictionary's value type. If the specified key isn't contained in the dictionary, the subscript returns .
 protocol.
.
, which is defined in the Swift standard library. In other words, the following two declarations are equivalent:
 is declared to have the type of an optional integer. Note that no whitespace may appear between the type and the .
, which are used to represent values that may or may not be present. Any type can be explicitly declared to be (or implicitly converted to) an optional type. If you don't provide an initial value when you declare an optional variable or property, its value automatically defaults to .
 results in a runtime error.

  You can also use optional chaining and optional binding to conditionally perform an operation on an optional expression. If the value is , no operation is performed and therefore no runtime error is produced.
.
, which is defined in the Swift standard library. In other words, the following two declarations are equivalent:
 is declared to have the type of an implicitly unwrapped optional string. Note that no whitespace may appear between the type and the .

  You can use implicitly unwrapped optionals in all the same places in your code that you can use optionals. For instance, you can assign values of implicitly unwrapped optionals to variables, constants, and properties of optionals, and vice versa.
.
 operator to unwrap it. That said, if you try to use an implicitly unwrapped optional that has a value of , you'll get a runtime error.

  Use optional chaining to conditionally perform an operation on an implicitly unwrapped optional expression. If the value is , no operation is performed and therefore no runtime error is produced.
.

  A protocol composition type describes a type that conforms to each protocol in a list of specified protocols. Protocol composition types may be used in type annotations and in generic parameters.

  A protocol composition type allows you to specify a value whose type conforms to the requirements of multiple protocols without having to explicitly define a new, named protocol that inherits from each protocol you want the type to conform to. For example, specifying a protocol composition type , but without having to introduce a new name.

  Each item in a protocol composition list must be either the name of protocol or a type alias of a protocol composition type. If the list is empty, it specifies the empty protocol composition type, which every type conforms to.

  A metatype type refers to the type of any type, including class types, structure types, enumeration types, and protocol types.
. The metatype of a protocol type—not the concrete type that conforms to the protocol at runtime—is the name of that protocol followed by . For example, the metatype of the class type .
 expression to access a type as a value. For example, . And  at runtime. You can use a 
  A type inheritance clause is used to specify which class a named type inherits from and which protocols a named type conforms to. A type inheritance clause is also used to specify a  requirement on a protocol. A type inheritance clause begins with a colon ( requirement, a list of type identifiers, or both.

  Class types can inherit from a single superclass and conform to any number of protocols. When defining a class, the name of the superclass must appear first in the list of type identifiers, followed by any number of protocols the class must conform to. If the class does not inherit from another class, the list can begin with a protocol instead. For an extended discussion and several examples of class inheritance, see .

  Other named types can only inherit from or conform to a list of protocols. Protocol types can inherit from any number of other protocols. When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated together, and any type that inherits from the current protocol must conform to all of those requirements. As discussed in  requirement.

  A type inheritance clause in an enumeration definition can be either a list of protocols, or in the case of an enumeration that assigns raw values to its cases, a single, named type that specifies the type of those raw values. For an example of an enumeration definition that uses a type inheritance clause to specify the type of its raw values, see .

  Swift uses type inference extensively, allowing you to omit the type or part of the type of many variables and expressions in your code. For example, instead of writing . Similarly, you can omit part of a type when the full type can be inferred from context. For instance, if you write .

  In both of the examples above, the type information is passed up from the leaves of the expression tree to its root. That is, the type of ).

  In Swift, type information can also flow in the opposite direction—from the root down to the leaves. In the following example, for instance, the explicit type annotation (.

  Type inference in Swift operates at the level of a single expression or statement. This means that all of the information needed to infer an omitted type or part of a type in an expression must be accessible from type-checking the expression or one of its subexpressions.
Copyright � 2015 Apple Inc. All rights reserved. 
  In Swift, there are four kinds of expressions: prefix expressions, binary expressions, primary expressions, and postfix expressions. Evaluating an expression returns a value, causes a side effect, or both.

  Prefix and binary expressions let you apply operators to smaller expressions. Primary expressions are conceptually the simplest kind of expression, and they provide a way to access values. Postfix expressions, like prefix and binary expressions, let you build up more complex expressions using postfixes such as function calls and member access. Each kind of expression is described in detail in the sections below.
 combine an optional prefix operator with an expression. Prefix operators take one argument, the expression that follows them.
.
 immediately before the name of a variable that's being passed as an in-out argument to a function call expression. For more information and to see an example, see .
 combine an infix binary operator with the expression that it takes as its left-hand and right-hand arguments. It has the following form:
.
At parse time, an expression made up of binary operators is represented as a flat list. This list is transformed into a tree by applying operator precedence. For example, the expression . This process transforms it into the tree (2 + (3 * 5)).
    	 sets a new value for a given expression. It has the following form:
. If the  must be a tuple with the same number of elements. (Nested tuples are allowed.) Assignment is performed from each part of the . For example:

  The assignment operator does not return any value.
 evaluates to one of two given values based on the value of a condition. It has the following form:
, the conditional operator evaluates the first expression and returns its value. Otherwise, it evaluates the second expression and returns its value. The unused expression is not evaluated.
.
 operator.
. It returns .
 operator performs a cast when it is known at compile time that the cast always succeeds, such as upcasting or bridging. Upcasting lets you use an expression as an instance of its type's supertype, without using an intermediate variable. The following approaches are equivalent:
 without needing to create a new instance. For more information on bridging, see .
. The . At runtime, if the cast succeeds, the value of . If casting to the specified  is guaranteed to fail or is guaranteed to succeed, a compile-time error is raised.
. The , not an optional type. If the cast fails, a runtime error is raised. The behavior of .
.
 are the most basic kind of expression. They can be used as expressions on their own, and they can be combined with other tokens to make prefix expressions, binary expressions, and postfix expressions.

  The name of the file in which it appears.

  The line number on which it appears.

  The column number in which it begins.

  The name of the declaration in which it appears.
 it is the name of that keyword, and at the top level of a file it is the name of the current module.

  When used as the default value of a function or method, the special literal's value is determined when the default value expression is evaluated at the call site.
 is an ordered collection of values. It has the following form:

  The last expression in the array can be followed by an optional comma. The value of an array literal has type  is the type of the expressions inside it. If there are expressions of multiple types,  is their closest common supertype. Empty array literals are written using an empty pair of square brackets and can be used to create an empty array of a specified type.
 is an unordered collection of key-value pairs. It has the following form:

  The last expression in the dictionary can be followed by an optional comma. The value of a dictionary literal has type  is the type of its value expressions. If there are expressions of multiple types,  are the closest common supertype for their respective values. An empty dictionary literal is written as a colon inside a pair of brackets () to distinguish it from an empty array literal. You can use an empty dictionary literal to create an empty dictionary literal of specified key and value types.
 expression is an explicit reference to the current type or instance of the type in which it occurs. It has the following forms:
 refers to the current instance of the type in which it occurs. In a type method,  refers to the current type in which it occurs.
 expression is used to specify scope when accessing members, providing disambiguation when there is another variable of the same name in scope, such as a function parameter. For example:
. For example:
 lets a class interact with its superclass. It has one of the following forms:

  The first form is used to access a member of the superclass. The second form is used to access the superclass's subscript implementation. The third form is used to access an initializer of the superclass.

  Subclasses can use a superclass expression in their implementation of members, subscripting, and initializers to make use of the implementation in their superclass.
 in other programming languages. Like function declarations, closures contain statements which they execute, and they capture values from their enclosing scope. It has the following form:
.

  A closure can omit the types of its parameters, its return type, or both. If you omit the parameter names and both types, omit the  keyword before the statements. If the omitted types can't be inferred, a compile-time error is raised.

  A closure may omit names for its parameters. Its parameters are then implicitly named , and so on.

  A closure that consists of only a single expression is understood to return the value of that expression. The contents of this expression are also considered when performing type inference on the surrounding expression.
.
. A capture list is written as a comma separated list surrounded by square brackets, before the list of parameters. If you use a capture list, you must also use the  keyword, even if you omit the parameter names, parameter types, and return type.
 to capture a weak or unowned reference to the value.

  You can also bind an arbitrary expression to a named value in the capture list. The expression is evaluated when the closure is formed, and captured with the specified strength. For example:
.
 is an abbreviated way to access a member of a type, such as an enumeration case or a type method, in a context where type inference can determine the implied type. It has the following form:
 consists of a comma-separated list of expressions surrounded by parentheses. Each expression can have an optional identifier before it, separated by a colon (). It has the following form:

  Use parenthesized expressions to create tuples and to pass arguments to a function call. If there is only one value inside the parenthesized expression, the type of the parenthesized expression is the type of that value. For example, the type of the parenthesized expression .
 is used to explicitly ignore a value during an assignment. For example, in the following assignment 10 is assigned to  are formed by applying a postfix operator or other postfix syntax to an expression. Syntactically, every primary expression is also a postfix expression.
.
 consists of a function name followed by a comma-separated list of the function's arguments in parentheses. Function call expressions have the following form:
 can be any expression whose value is of a function type.
). This kind of function call expression has the following form:

  A function call expression can include a trailing closure in the form of a closure expression immediately after the closing parenthesis. The trailing closure is understood as an argument to the function, added after the last parenthesized argument. The following function calls are equivalent:

  If the trailing closure is the function's only argument, the parentheses can be omitted.
 provides access to a type's initializer. It has the following form:

  You use the initializer expression in a function call expression to initialize a new instance of a type. Unlike functions, an initializer can't be used as a value. For example:

  You also use an initializer expression to delegate to the initializer of a superclass.
 allows access to the members of a named type, a tuple, or a module. It consists of a period () between the item and the identifier of its member.

  The members of a named type are named as part of the type's declaration or extension. For example:

  The members of a tuple are implicitly named using integers in the order they appear, starting from zero. For example:

  The members of a module access the top-level declarations of that module.
. It has the following forms:
. For example, .
. Use this form to access a type as a value. For example, because  type itself, you can pass it to a function or method that accepts a type-level argument.
. It has the following form:
 can't be the name of a type. The entire  provides subscript access using the getter and setter of the corresponding subscript declaration. It has the following form:
 passed as the subscript parameters. To set its value, the subscript setter is called in the same way.
.
. It has the following form:
, the optional value is unwrapped and returned with the corresponding nonoptional type. Otherwise, a runtime error is raised.

  The unwrapped value of a forced-value expression can be modified, either by mutating the value itself, or by assigning to one of the value's members. For example:
 provides a simplified syntax for using optional values in postfix expressions. It has the following form:

  Optional-chaining expressions must appear within a postfix expression, and they cause the postfix expression to be evaluated in a special way. If the optional-chaining expression is . If the optional-chaining expression is not , the value of the optional-chaining expression is unwrapped and used to evaluate the rest of the postfix expression. In either case, the value of the postfix expression is still of an optional type.

  If a postfix expression that contains an optional-chaining expression is nested inside other postfix expressions, only the outermost expression returns an optional type. In the example below, when . The entire expression  has a value of an optional type.

  The following example shows the behavior of the example above without using optional chaining.

  The unwrapped value of an optional-chaining expression can be modified, either by mutating the value itself, or by assigning to one of the value's members. If the value of the optional-chaining expression is , the expression on the right hand side of the assignment operator is not evaluated. For example:
Copyright � 2015 Apple Inc. All rights reserved. 
  In Swift, there are two kinds of statements: simple statements and control flow statements. Simple statements are the most common and consist of either an expression or a declaration. Control flow statements are used to control the flow of execution in a program. There are three types of control flow statements in Swift: loop statements, branch statements, and control transfer statements.

  Loop statements allow a block of code to be executed repeatedly, branch statements allow a certain block of code to be executed only when certain conditions are met, and control transfer statements provide a way to alter the order in which code is executed. Each type of control flow statement is described in detail below.
) can optionally appear after any statement and is used to separate multiple statements if they appear on the same line.

  Loop statements allow a block of code to be executed repeatedly, depending on the conditions specified in the loop. Swift has four loop statements: a  statement.
 below.
 statement allows a block of code to be executed repeatedly while incrementing a counter, as long as a condition remains true.
 are required. The braces around the  in the body of the loop are also required.
 is evaluated only once. It is typically used to declare and initialize any variables that are needed for the remainder of the loop.
 expression is evaluated.
, and execution continues to step 3. If  statement.
 expression is evaluated, and execution returns to step 2.
 statement itself.
 protocol.
 protocol.
 protocol. The program begins executing a loop by calling the  method on the stream. If the value returned is not , and then continues execution at the beginning of the loop. Otherwise, the program does not perform assignment or execute the  statement.
 statement allows a block of code to be executed repeatedly, as long as a condition remains true.
 is evaluated.
, execution continues to step 2. If  statement.
, and execution returns to step 1.
 statement can be executed zero or more times.
 protocol. The condition can also be an optional binding declaration, as discussed in .
 statement allows a block of code to be executed one or more times, as long as a condition remains true.
, and execution continues to step 2.
 is evaluated.
, execution returns to step 1. If  statement.
 statement are executed at least once.
 protocol. The condition can also be an optional binding declaration, as discussed in .

  Branch statements allow the program to execute certain parts of code depending on the value of one or more conditions. The values of the conditions specified in a branch statement control how the program branches and, therefore, what block of code is executed. Swift has two branch statements: an  statement.
 below.
 statement is used for executing code based on the evaluation of one or more conditions.
 statement. In each form, the opening and closing braces are required.
 keyword) and is used for executing one part of code when the condition is true and another part of code when the same condition is false. When a single else clause is present, an  statement to test more than one condition. An  protocol. The condition can also be an optional binding declaration, as discussed in .
 statement allows certain blocks of code to be executed depending on the value of a control expression.
 statement is evaluated and then compared with the patterns specified in each case. If a match is found, the program executes the  listed within the scope of that case. The scope of each case can't be empty. As a result, you must include at least one statement following the colon () of each case label. Use a single  statement if you don't intend to execute any code in the body of a matched case.

  The values of expressions your code can branch on are very flexible. For instance, in addition to the values of scalar types, such as integers and characters, your code can branch on the values of any type, including floating-point numbers, strings, tuples, instances of custom classes, and optionals. The value of the  can even be matched to the value of a case in an enumeration and checked for inclusion in a specified range of values. For examples of how to use these various types of values in  chapter.
 case can optionally contain a guard expression after each pattern. A . If a guard expression is present, the . For instance, a .
). These constants (or variables) can then be referenced in a corresponding guard expression and throughout the rest of the code within the scope of the case. That said, if the case contains multiple patterns that match the control expression, none of those patterns can contain constant or variable bindings.
. The code within a default case is executed only if no other cases match the control expression. A  statement.
 statement behaves as if the evaluation is performed in source order—that is, the order in which they appear in source code. As a result, if multiple cases contain patterns that evaluate to the same value, and thus can match the value of the control expression, the program executes only the code within the first matching case in source order.

  In Swift, every possible value of the control expression's type must match the value of at least one pattern of a case. When this simply isn't feasible (for instance, when the control expression's type is ), you can include a default case to satisfy the requirement.
 statement. Program execution does not continue or “fall through” to the next case or default case. That said, if you want execution to continue from one case to the next, explicitly include a , in the case from which you want execution to continue. For more information about the  below.
, which consists of the name of the label followed immediately by a colon (:). Use statement labels with  below.

  The scope of a labeled statement is the entire statement following the statement label. You can nest labeled statements, but the name of each statement label must be unique.
 chapter.

  Control transfer statements can change the order in which code in your program is executed by unconditionally transferring program control from one piece of code to another. Swift has four control transfer statements: a  statement.
 statement. A  followed by the name of a statement label, as shown below.
 statement named by that label.
 statement or the innermost enclosing loop statement in which it occurs.
 statement, if any.
 chapter.
 statement ends program execution of the current iteration of a loop statement but does not stop execution of the loop statement. A  followed by the name of a statement label, as shown below.
 statement is followed by the name of a statement label, it ends program execution of the current iteration of the loop statement named by that label.
 statement is not followed by the name of a statement label, it ends program execution of the current iteration of the innermost enclosing loop statement in which it occurs.

  In both cases, program control is then transferred to the condition of the enclosing loop statement.
 statement is executed, because the increment expression is evaluated after the execution of the loop's body.
 chapter.
 statement. A  statement to the next case. Program execution continues to the next case even if the patterns of the case label do not match the value of the  statement's control expression.
 statement, not just as the last statement of a case block, but it can't be used in the final case block. It also cannot transfer control into a case block whose pattern contains value binding patterns.
 chapter.
 statement occurs in the body of a function or method definition and causes program execution to return to the calling function or method. Program execution continues at the point immediately following the function or method call.
 followed by an expression, as shown below.
 statement is followed by an expression, the value of the expression is returned to the calling function or method. If the value of the expression does not match the value of the return type declared in the function or method declaration, the expression's value is converted to the return type before it is returned to the calling function or method.
) can be used in a failable initializer to indicate initialization failure.
    	).
Copyright � 2015 Apple Inc. All rights reserved.  introduces a new name or construct into your program. For example, you use declarations to introduce functions and methods, variables and constants, and to define new, named enumeration, structure, class, and protocol types. You can also use a declaration to extend the behavior of an existing named type and to import symbols into your program that are declared elsewhere.

  In Swift, most declarations are also definitions in the sense that they are implemented or initialized at the same time they are declared. That said, because protocols don't implement their members, most protocol members are declarations only. For convenience and because the distinction isn't that important in Swift, the term  covers both declarations and definitions.

  The top-level code in a Swift source file consists of zero or more statements, declarations, and expressions. By default, variables, constants, and other named declarations that are declared at the top-level of a source file are accessible to code in every source file that is part of the same module. You can override this default behavior by marking the declaration with an access level modifier, as described in .
 is used by a variety of declarations and control structures to group statements together. It has the following form:
 inside a code block include declarations, expressions, and other kinds of statements and are executed in order of their appearance in source code.
 lets you access symbols that are declared outside the current file. The basic form imports the entire module; it consists of the 
  Providing more detail limits which symbols are imported—you can specify a specific submodule or a specific declaration within a module or submodule. When this detailed form is used, only the imported symbol (and not the module that declares it) is made available in the current scope.
 introduces a constant named value into your program. Constant declarations are declared using the keyword ; after the value of a constant is set, it cannot be changed. That said, if a constant is initialized with a class object, the object itself can change, but the binding between the constant name and the object it refers to can't.

  When a constant is declared at global scope, it must be initialized with a value. When a constant declaration occurs in the context of a class or structure declaration, it is considered a . Constant declarations are not computed properties and therefore do not have getters or setters.
.
. Both constants can now be used independently:
.
 declaration modifier. Type properties are discussed in .
.
.

  Variable declarations have several forms that declare different kinds of named, mutable values, including stored and computed variables and properties, stored variable and property observers, and static variable properties. The appropriate form to use depends on the scope at which the variable is declared and the kind of variable you intend to declare.
.
    	.

  You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class or structure declaration. When a variable declaration of this form is declared at global scope or the local scope of a function, it is referred to as a . When it is declared in the context of a class or structure declaration, it is referred to as a .
 is optional. That said, if no initializer ).
.

  As their names suggest, the value of a stored variable or a stored variable property is stored in memory.

  You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class, structure, enumeration, or extension declaration. When a variable declaration of this form is declared at global scope or the local scope of a function, it is referred to as a . When it is declared in the context of a class, structure, or extension declaration, it is referred to as a .

  The getter is used to read the value, and the setter is used to write the value. The setter clause is optional, and when only a getter is needed, you can omit both clauses and simply return the requested value directly, as described in . But if you provide a setter clause, you must also provide a getter clause.
 and enclosing parentheses is optional. If you provide a setter name, it is used as the name of the parameter to the setter. If you do not provide a setter name, the default parameter name to the setter is .

  Unlike stored named values and stored variable properties, the value of a computed named value or a computed property is not stored in memory.
.
 observers. A stored variable or property declared with observers has the following form:

  You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class or structure declaration. When a variable declaration of this form is declared at global scope or the local scope of a function, the observers are referred to as . When it is declared in the context of a class or structure declaration, the observers are referred to as .

  You can add property observers to any stored property. You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass, as described in .
 is optional in the context of a class or structure declaration, but required elsewhere. The .
 observers provide a way to observe (and to respond appropriately) when the value of a variable or property is being set. The observers are not called when the variable or property is first initialized. Instead, they are called only when the value is set outside of an initialization context.
 observer is called just before the value of the variable or property is set. The new value is passed to the  clause. The  observer is called immediately after the new value is set. In contrast to the  observer in case you still need access to it. That said, if you assign a value to a variable or property within its own  observer.
 clauses are optional. If you provide setter names, they are used as the parameter names to the  observers. If you do not provide setter names, the default parameter name to the .
 clause. Likewise, the  clause.
.
 declaration modifier. Classes may mark type computed properties with the  declaration modifier instead to allow subclasses to override the superclass's implementation. Type properties are discussed in .
 declaration modifiers.
    	 introduces a named alias of an existing type into your program. Type alias declarations are declared using the keyword  everywhere in your program. The  can be a named type or a compound type. Type aliases do not create new types; they simply allow a name to refer to an existing type.
.
 introduces a function or method into your program. A function declared in the context of class, structure, enumeration, or protocol is referred to as a . Function declarations are declared using the keyword 
  The type of each parameter must be included—it can't be inferred. Although the parameters to a function are constants by default, you can write  in front of a parameter's name to emphasize this behavior. Write  to make those changes also apply to the argument that was passed in the caller's scope. For a discussion of in-out parameters, see .

  Functions can return multiple values using a tuple type as the return type of the function.

  A function definition can appear inside another function declaration. This kind of function is known as a . For a discussion of nested functions, see .

  Function parameters are a comma separated list where each parameter has one of several forms. The order of arguments in a function call must match the order of parameters in the function's declaration. The simplest entry in a parameter list has the following form:

  For function parameters, the parameter name is used within the function body, but is not used when calling the function. For method parameters, the parameter name is used as within the function body, and is also used as a label for the argument when calling the method. The name of a method's first parameter is used only within the function body, like the parameter of a function. For example:

  A second name before the local parameter name gives the parameter an external name, which can be different from the local parameter name. The external parameter name must be used when the function is called. The corresponding argument must have the external name in function or method calls.
) before a parameter name indicates that the name should be used as both an external and a local parameter name. It has the same meaning as writing the local parameter name twice. The corresponding argument must have this name in function or method calls.
) before a local parameter name gives that parameter no name to be used in function calls. The corresponding argument must have no name in function or method calls.
) is explicitly ignored and can't be accessed within the body of the function.
) is understood as a variadic parameter. A function can have at most one variadic parameter, which must be its last parameter. A variadic parameter is treated as an array that contains elements of the base type name. For instance, the variadic parameter . For an example that uses a variadic parameter, see .
) and an expression after its type is understood to have a default value of the given expression. The given expression is evaluated when the function is called. If the parameter is omitted when calling the function, the default value is used instead. If the parameter is not omitted, it must have its name in the function call.
 declaration modifier.
 declaration modifier. It's a compile-time error to override a method without the  modifier on a method that doesn't override a superclass method.
 declaration modifier for classes.

  You can rewrite a function that takes multiple parameters as an equivalent function that takes a single parameter and returns a function. The returned function takes the next parameter and returns another function. This continues until there are no remaining parameters, at which point the last function returns the return value of the original multiparameter function. The rewritten function is known as a . For example, you can rewrite the  function takes two integers and returns the result of adding them together. The  function takes a single integer, and returns another function that takes the second integer and adds it to the first. (The nested function captures the value of the first integer argument from the enclosing function.)

  Although you must provide the arguments to a noncurried function all at once in a single call, you can use the curried form of a function to provide arguments in several function calls, one at a time (even in different places in your code). This is known as . For example, you can apply the  to the argument.
 introduces a named enumeration type into your program.
. The body of an enumeration declared using either form contains zero or more values—called —and any number of declarations, including computed properties, instance methods, type methods, initializers, type aliases, and even other enumeration, structure, and class declarations. Enumeration declarations can't contain deinitializer or protocol declarations.

  Enumeration types can adopt any number of protocols, but can't inherit from classes, structures, or other enumerations.

  Unlike classes and structures, enumeration types do not have an implicitly provided default initializer; all initializers must be declared explicitly. Initializers can delegate to other initializers in the enumeration, but the initialization process is complete only after an initializer assigns one of the enumeration cases to .

  Like structures but unlike classes, enumerations are value types; instances of an enumeration are copied when assigned to variables or constants, or when passed as arguments to a function call. For information about value types, see .
.
 in other programming languages.
 followed by one or more enumeration cases, separated by commas. The name of each case must be unique. Each case can also specify that it stores values of a given type. These types are specified in the  tuple, immediately following the name of the case. For more information and to see examples of cases with associated value types, see .
, followed by one or more enumeration cases, separated by commas. Unlike the cases in the first form, each case has an underlying value, called a , of the same basic type. The type of these values is specified in the  and must represent an integer, floating-point number, string, or single character. In particular, the  for string literals that contain only a single character.

  Each case must have a unique name and be assigned a unique raw value. If the raw-value type is specified as , and so on. Each unassigned case of type  is implicitly assigned a raw value that is automatically incremented from the raw value of the previous case.
. And because the value of .
 protocol, defined in the Swift standard library. As a result, they have a . You can use the . You can also use a raw value to find a corresponding case, if there is one, by calling the enumeration's failable initializer, as in , which returns an optional case. For more information and to see examples of cases with raw-value types, see .
. When the enumeration type can be inferred from context, you can omit it (the dot is still required), as described in .
. The enumeration type is pattern-matched against the enumeration case patterns in the case blocks of the .
 introduces a named structure type into your program. Structure declarations are declared using the keyword . These  can include both stored and computed properties, type properties, instance methods, type methods, initializers, subscripts, type aliases, and even other structure, class, and enumeration declarations. Structure declarations can't contain deinitializer or protocol declarations. For a discussion and several examples of structures that include various kinds of declarations, see .

  Structure types can adopt any number of protocols, but can't inherit from classes, enumerations, or other structures.
.
.
.
.
.

  Structures are value types; instances of a structure are copied when assigned to variables or constants, or when passed as arguments to a function call. For information about value types, see .
.
 introduces a named class type into your program. Class declarations are declared using the keyword . These  can include both stored and computed properties, instance methods, type methods, initializers, a single deinitializer, subscripts, type aliases, and even other class, structure, and enumeration declarations. Class declarations can't contain protocol declarations. For a discussion and several examples of classes that include various kinds of declarations, see .
, but can adopt any number of protocols. The . Generic classes can inherit from other generic and nongeneric classes, but a nongeneric class can inherit only from other nongeneric classes. When you write the name of a generic superclass class after the colon, you must include the full name of that generic class, including its generic parameter clause.
, classes can have designated and convenience initializers. The designated initializer of a class must initialize all of the class's declared properties and it must do so before calling any of its superclass's designated initializers.

  A class can override properties, methods, subscripts, and initializers of its superclass. Overridden properties, methods, subscripts, and designated initializers must be marked with the  declaration modifier.
 declaration modifier. The subclass's implementation of that initializer must also be marked with the  declaration modifier.
 are not. That said, if the current class overrides all of the superclass's designated initializers, it inherits the superclass's convenience initializers. Swift classes do not inherit from a universal base class.
.
.
.

  Classes are reference types; instances of a class are referred to, rather than copied, when assigned to variables or constants, or when passed as arguments to a function call. For information about reference types, see .
.
 introduces a named protocol type into your program. Protocol declarations are declared at global scope using the keyword , which describe the conformance requirements that any type adopting the protocol must fulfill. In particular, a protocol can declare that conforming types must implement certain properties, methods, initializers, and subscripts. Protocols can also declare special kinds of type aliases, called , that can specify relationships among the various declarations of the protocol. Protocol declarations can't contain class, structure, enumeration, or other protocol declarations. The  are discussed in detail below.

  Protocol types can inherit from any number of other protocols. When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated, and any type that inherits from the current protocol must conform to all those requirements. For an example of how to use protocol inheritance, see .
.
    	
  You can add protocol conformance to a previously declared type by adopting the protocol in an extension declaration of that type. In the extension, you must implement all of the adopted protocol's requirements. If the type already implements all of the requirements, you can leave the body of the extension declaration empty.

  By default, types that conform to a protocol must implement all properties, methods, and subscripts declared in the protocol. That said, you can mark these protocol member declarations with the  declaration modifier to specify that their implementation by a conforming type is optional. The  attribute. As a result, only class types can adopt and conform to a protocol that contains optional member requirements. For more information about how to use the .
 list after the colon. For example, the following protocol can be adopted only by class types:
 requirement can likewise be adopted only by class types.
 requirement explicitly.
    	. However, you can't construct an instance of a protocol, because protocols do not actually provide the implementations for the requirements they specify.
.
 in the body of the protocol declaration. Protocol property declarations have a special form of a variable declaration:

  As with other protocol member declarations, these property declarations declare only the getter and setter requirements for types that conform to the protocol. As a result, you don't implement the getter or setter directly in the protocol in which it is declared.

  The getter and setter requirements can be satisfied by a conforming type in a variety of ways. If a property declaration includes both the  keywords, a conforming type can implement it with a stored variable property or a computed property that is both readable and writeable (that is, one that implements both a getter and a setter). However, that property declaration can't be implemented as a constant property or a read-only computed property. If a property declaration includes only the  keyword, it can be implemented as any kind of property. For examples of conforming types that implement the property requirements of a protocol, see .
.

  Protocols declare that conforming types must implement a method by including a protocol method declaration in the body of the protocol declaration. Protocol method declarations have the same form as function declarations, with two exceptions: They don't include a function body, and you can't provide any default parameter values as part of the function declaration. For examples of conforming types that implement the method requirements of a protocol, see .
 declaration modifier. Classes that implement this method declare the method with the  modifier. Structures that implement it must declare the method with the  declaration modifier instead. If you're implementing the method in an extension, use the  modifier if you're extending a structure.
.

  Protocols declare that conforming types must implement an initializer by including a protocol initializer declaration in the body of the protocol declaration. Protocol initializer declarations have the same form as initializer declarations, except they don't include the initializer's body.
 failable initializer. A conforming type can satisfy a failable protocol initializer requirement by implementing any kind of initializer.
 declaration modifier.
.

  Protocols declare that conforming types must implement a subscript by including a protocol subscript declaration in the body of the protocol declaration. Protocol subscript declarations have a special form of a subscript declaration:

  Subscript declarations only declare the minimum getter and setter implementation requirements for types that conform to the protocol. If the subscript declaration includes both the  keywords, a conforming type must implement both a getter and a setter clause. If the subscript declaration includes only the  a getter clause and optionally can implement a setter clause.
.
. An associated type provides an alias for a type that is used as part of a protocol's declaration. Associated types are similar to type parameters in generic parameter clauses, but they're associated with  in the protocol in which they're declared. In that context,  refers to the eventual type that conforms to the protocol. For more information and examples, see .
.
 introduces an initializer for a class, structure, or enumeration into your program. Initializer declarations are declared using the keyword  and have two basic forms.

  Structure, enumeration, and class types can have any number of initializers, but the rules and associated behavior for class initializers are different. Unlike structures and enumerations, classes have two kinds of initializers: designated initializers and convenience initializers, as described in .

  A designated initializer of a class initializes all of the class's properties directly. It can't call any other initializers of the same class, and if the class has a superclass, it must call one of the superclass's designated initializers. If the class inherits any properties from its superclass, one of the superclass's designated initializers must be called before any of these properties can be set or modified in the current class.

  Designated initializers can be declared in the context of a class declaration only and therefore can't be added to a class using an extension declaration.

  Initializers in structures and enumerations can call other declared initializers to delegate part or all of the initialization process.
 declaration modifier.

  Convenience initializers can delegate the initialization process to another convenience initializer or to one of the class's designated initializers. That said, the initialization processes must end with a call to a designated initializer that ultimately initializes the class's properties. Convenience initializers can't call a superclass's initializers.
 declaration modifier to require that every subclass implement the initializer. A subclass's implementation of that initializer must also be marked with the  declaration modifier.

  By default, initializers declared in a superclass are not inherited by subclasses. That said, if a subclass initializes all of its stored properties with default values and doesn't define any initializers of its own, it inherits all of the superclass's initializers. If the subclass overrides all of the superclass's designated initializers, it inherits the superclass's convenience initializers.
 declaration modifier.
 modifier when you override the required initializer in a subclass.
    	.
 is a type of initializer that produces an optional instance or an implicitly unwrapped optional instance of the type the initializer is declared on. As a result, a failable initializer can return  to indicate that initialization failed.
). To declare a failable initializer that produces an implicitly unwrapped optional instance, append an exclamation mark instead (). The example below shows an  failable initializer that produces an optional instance of a structure.
 failable initializer in the same way that you call a nonfailable initializer, except that you must deal with the optionality of the result.
 at any point in the implementation of the initializer's body. A failable initializer of a class, however, can return  is called (that is, any initializer delegation is performed).

  A failable initializer can delegate to any kind of initializer. A nonfailable initializer can delegate to another nonfailable initializer or to an  failable initializer.

  Initialization failure propagates through initializer delegation. Specifically, if a failable initializer delegates to an initializer that fails and returns . If a nonfailable initializer delegates to an  value).

  A failable designated initializer can be overridden in a subclass by any kind of designated initializer. A nonfailable designated initializer can be overridden in a subclass by a nonfailable designated initializer only.
.
 declares a deinitializer for a class type. Deinitializers take no parameters and have the following form:

  A deinitializer is called automatically when there are no longer any references to a class object, just before the class object is deallocated. A deinitializer can be declared only in the body of a class declaration—but not in an extension of a class—and each class can have at most one.

  A subclass inherits its superclass's deinitializer, which is implicitly called just before the subclass object is deallocated. The subclass object is not deallocated until all deinitializers in its inheritance chain have finished executing.

  Deinitializers are not called directly.
.
 allows you to extend the behavior of existing class, structure, and enumeration types. Extension declarations are declared using the keyword . These  can include computed properties, computed type properties, instance methods, type methods, initializers, subscript declarations, and even class, structure, and enumeration declarations. Extension declarations can't contain deinitializer or protocol declarations, stored properties, property observers, or other extension declarations. For a discussion and several examples of extensions that include various kinds of declarations, see .
. Extension declarations can't add class inheritance to an existing class, and therefore you can specify only a list of protocols after the  and colon.

  Properties, methods, and initializers of an existing type can't be overridden in an extension of that type.

  Extension declarations can contain initializer declarations. That said, if the type you're extending is defined in another module, an initializer declaration must delegate to an initializer already defined in that module to ensure members of that type are properly initialized.
 declaration allows you to add subscripting support for objects of a particular type and are typically used to provide a convenient syntax for accessing the elements in a collection, list, or sequence. Subscript declarations are declared using the keyword 
  Subscript declarations can appear only in the context of a class, structure, enumeration, extension, or protocol declaration.
). Although the indexes used to access the elements can be of any type, each parameter must include a type annotation to specify the type of each index. The  specifies the type of the element being accessed.

  As with computed properties, subscript declarations support reading and writing the value of the accessed elements. The getter is used to read the value, and the setter is used to write the value. The setter clause is optional, and when only a getter is needed, you can omit both clauses and simply return the requested value directly. That said, if you provide a setter clause, you must also provide a getter clause.
 and enclosing parentheses are optional. If you provide a setter name, it is used as the name of the parameter to the setter. If you do not provide a setter name, the default parameter name to the setter is . The type of the .
 differ from the one you're overloading. You can also override a subscript declaration inherited from a superclass. When you do so, you must mark the overridden subscript declaration with the  declaration modifier.
.
.
.

  You can declare operators of three different fixities: infix, prefix, and postfix. The  of an operator specifies the relative position of an operator to its operands.

  There are three basic forms of an operator declaration, one for each fixity. The fixity of the operator is specified by marking the operator declaration with the  keyword. In each form, the name of the operator can contain only the operator characters defined in .
.

  Infix operators can optionally specify a precedence, associativity, or both.
 of an operator specifies how tightly an operator binds to its operands in the absence of grouping parentheses. You specify the precedence of an operator by writing the context-sensitive keyword . The  can be any whole number (decimal integer) from 0 to 255; unlike decimal integer literals, it can't contain any underscore characters. Although the precedence level is a specific number, it is significant only relative to another operator. That is, when two operators compete with each other for their operands, such as in the expression , the operator with the higher precedence level binds more tightly to its operands.
 of an operator specifies how a sequence of operators with the same precedence level are grouped together in the absence of grouping parentheses. You specify the associativity of an operator by writing the context-sensitive keyword . Operators that are left-associative group left-to-right. For example, the subtraction operator (. Operators that are right-associative group right-to-left, and operators that are specified with an associativity of  don't associate at all. Nonassociative operators of the same precedence level can't appear adjacent to each to other. For example,  is not a valid expression.
.
.

  Prefix operators declarations don't specify a precedence level. Prefix operators are nonassociative.
.

  As with prefix operators, postfix operator declarations don't specify a precedence level. Postfix operators are nonassociative.

  After declaring a new operator, you implement it by declaring a function that has the same name as the operator. If you're implementing a prefix or postfix operator, you must also mark that function declaration with the corresponding  declaration modifier. If you're implementing an infix operator, you don't mark that function declaration with the  declaration modifier. To see an example of how to create and implement a new operator, see .
 are keywords or context-sensitive keywords that modify the behavior or meaning of a declaration. You specify a declaration modifier by writing the appropriate keyword or context-sensitive keyword between a declaration's attributes (if any) and the keyword that introduces the declaration.

  Apply this modifier to any member of a class that can be represented by Objective-C. When you mark a member declaration with the  modifier, access to that member is always dynamically dispatched using the Objective-C runtime. Access to that member is never inlined or devirtualized by the compiler.
 attribute.

  Apply this modifier to a class or to a property, method, or subscript member of a class. It's applied to a class to indicate that the class can't be subclassed. It's applied to a property, method, or subscript of a class to indicate that a class member can't be overridden in any subclass.

  Apply this modifier to a stored variable property of a class or structure to indicate that the property's initial value is calculated and stored at most once, when the property is first accessed. For an example of how to use the .

  Apply this modifier to a protocol's property, method, or subscript members to indicate that a conforming type isn't required to implement those members.
 attribute. As a result, only class types can adopt and conform to a protocol that contains optional member requirements. For more information about how to use the .

  Apply this modifier to a designated or convenience initializer of a class to indicate that every subclass must implement that initializer. The subclass's implementation of that initializer must also be marked with the  modifier.
 modifier is applied to a variable or a stored variable property to indicate that the variable or property has a weak reference to the object stored as its value. The type of the variable or property must be an optional class type. Use the  modifier to avoid strong reference cycles. For an example and more information about the .

  Swift provides three levels of access control: public, internal, and private. You can mark a declaration with one of the access-level modifiers below to specify the declaration's access level. Access control is discussed in detail in .

  Apply this modifier to a declaration to indicate the declaration can be accessed by code in the same module as the declaration. Declarations marked with the  access-level modifier can also be accessed by code in a module that imports the module that contains that declaration.

  Apply this modifier to a declaration to indicate the declaration can be accessed only by code in the same module as the declaration. By default, most declarations are implicitly marked with the  access-level modifier.

  Apply this modifier to a declaration to indicate the declaration can be accessed only by code in the same source file as the declaration.
). Use this form of an access-level modifier when you want to specify an access level for the setter of a variable or subscript that's less than or equal to the access level of the variable or subscript itself, as discussed in .
Copyright � 2015 Apple Inc. All rights reserved.  provide more information about a declaration or type. There are two kinds of attributes in Swift, those that apply to declarations and those that apply to types.

  Some declaration attributes accept arguments that specify more information about the attribute and how it applies to a particular declaration. These  are enclosed in parentheses, and their format is defined by the attribute they belong to.

  You can apply a declaration attribute to declarations only. However, you can also apply the .

  Apply this attribute to any declaration to indicate the declaration's lifecycle relative to certain platforms and operating system versions.
 attribute always appears with a list of two or more comma-separated attribute arguments. These arguments begin with one of the following platform names: . You can also use an asterisk () to indicate the availability of the declaration on all of the platform names listed above. The remaining arguments can appear in any order and specify additional information about the declaration's lifecycle, including important milestones.
 argument indicates that the declaration isn't available on the specified platform.
 argument indicates the first version of the specified platform in which the declaration was introduced. It has the following form:
 consists of a positive integer or floating-point decimal number.
 argument indicates the first version of the specified platform in which the declaration was deprecated. It has the following form:
 consists of a positive integer or floating-point decimal number.
 argument indicates the first version of the specified platform in which the declaration was obsoleted. When a declaration is obsoleted, it's removed from the specified platform and can no longer be used. It has the following form:
 consists of a positive integer or floating-point decimal number.
 argument is used to provide a textual message that's displayed by the compiler when emitting a warning or error about the use of a deprecated or obsoleted declaration. It has the following form:
 consists of a string literal.
 argument is used to provide a textual message that indicates the new name for a declaration that's been renamed. The new name is displayed by the compiler when emitting an error about the use of a renamed declaration. It has the following form:
 consists of a string literal.
 argument and a type alias declaration to indicate to clients of your code that a declaration has been renamed. For example, this is useful when the name of a declaration is changed between releases of a framework or library.
 attributes on a single declaration to specify the declaration's availability on different platforms. The compiler uses an  attribute only when the attribute specifies a platform that matches the current target platform.

  This attribute is used to delay the evaluation of an expression by automatically wrapping that expression in a closure with no arguments. Apply this attribute to a parameter declaration for a function or method type that takes no arguments and that returns the type of the expression. Declarations with the . For an example of how to use the .

  Apply this attribute to a function or method declaration to indicate that a parameter it will not be stored for later execution, such that it is guaranteed not to outlive the lifetime of the call. Function type parameters with the  for properties or methods.
. You can mark a function or method type with this attribute to indicate that the function or method doesn't return to its caller.
 attribute with a function or method that is. That said, you can't override a function or method that is marked with the  attribute with a function or method that is not. Similar rules apply when you implement a protocol method in a conforming type.

  Apply this attribute to a class to indicate that it is the application delegate. Using this attribute is equivalent to calling the  function and passing this class's name as the name of the delegate class.
 function. For example, if your app uses a custom subclass of  function instead of using this attribute.

  Apply this attribute to a stored variable property of a class. This attribute causes the property's setter to be synthesized with a  method—instead of the value of the property itself. The type of the property must conform to the  protocol.
 property attribute.
 to indicate that the storage and implementation of the property are provided dynamically by Core Data at runtime based on the associated entity description.

  Apply this attribute to any declaration that can be represented in Objective-C—for example, non-nested classes, protocols, nongeneric enumerations (constrained to integer raw-value types), properties and methods (including getters and setters) of classes and protocols, initializers, deinitializers, and subscripts. The  attribute tells the compiler that a declaration is available to use in Objective-C code.
 attribute to a class or protocol, it's implicitly applied to the members of that class or protocol. The compiler also implicitly adds the  attribute. Protocols marked with the  attribute can't inherit from protocols that aren't.
 attribute to an enumeration, each enumeration case is exposed to Objective-C code as the concatenation of the enumeration name and the case name. For example, a case named .
 attribute optionally accepts a single attribute argument, which consists of an identifier. Use this attribute when you want to expose a different name to Objective-C for the entity the  attribute applies to. You can use this argument to name classes, protocols, methods, getters, setters, and initializers. The example below exposes the getter for the  rather than just as the name of the property itself.

  Apply this attribute to a class to indicate that it is the application delegate. Using this attribute is equivalent to calling the  function and passing this class's name as the name of the delegate class.
 function. For example, if your app uses a custom subclass of  function instead of using this attribute.

  Interface Builder attributes are declaration attributes used by Interface Builder to synchronize with Xcode. Swift provides the following Interface Builder attributes: . These attributes are conceptually the same as their Objective-C counterparts.
 attributes to property declarations of a class. You apply the  attribute to class declarations.

  You can apply type attributes to types only. However, you can also apply the .

  Apply this attribute to the type of a function or method to indicate that the function or method doesn't return to its caller. You can also mark a function or method declaration with this attribute to indicate that the corresponding type of that function or method, .
Copyright � 2015 Apple Inc. All rights reserved.  represents the structure of a single value or a composite value. For example, the structure of a tuple  is a comma-separated list of two elements. Because patterns represent the structure of a value rather than any one particular value, you can match them with a variety of values. For instance, the pattern  and any other two-element tuple. In addition to matching a pattern with a value, you can extract part or all of a composite value and bind each part to a constant or variable name.
 statements (in their case labels). Although any pattern can occur in the case labels of a  statement, in the other contexts, only wildcard patterns, identifier patterns, and patterns containing those two patterns can occur.

  You can specify a type annotation for a wildcard pattern, an identifier pattern, and a tuple pattern to constrain the pattern to match only values of a certain type.
). Use a wildcard pattern when you don't care about the values being matched against. For example, the following code iterates through the closed range  matches any value and binds the matched value to a variable or constant name. For example, in the following constant declaration, .

  When the pattern on the left-hand side of a variable or constant declaration is an identifier pattern, the identifier pattern is implicitly a subpattern of a value-binding pattern.
 binds matched values to variable or constant names. Value-binding patterns that bind a matched value to the name of a constant begin with the keyword .

  Identifiers patterns within a value-binding pattern bind new named variables or constants to their matching values. For example, you can decompose the elements of a tuple and bind the value of each element to a corresponding identifier pattern.
. Because of this behavior, the  match the same values.
 is a comma-separated list of zero or more patterns, enclosed in parentheses. Tuple patterns match values of corresponding tuple types.

  You can constrain a tuple pattern to match certain kinds of tuple types by using type annotations. For example, the tuple pattern . To constrain only some elements of a tuple pattern, provide type annotations directly to those individual elements. For example, the tuple pattern in .
 statement or in a variable or constant declaration, it can contain only wildcard patterns, identifier patterns, or other tuple patterns that contain those. For example, the following code isn't valid because the element 
  The parentheses around a tuple pattern that contains a single element have no effect. The pattern matches values of that single element's type. For example, the following are equivalent:
 matches a case of an existing enumeration type. Enumeration case patterns appear only in  statement case labels.

  If the enumeration case you're trying to match has any associated values, the corresponding enumeration case pattern must specify a tuple pattern that contains one element for each associated value. For an example that uses a .
 pattern. Both type-casting patterns appear only in  statement case labels. The  pattern—or a subclass of that type. The  operator in that they both perform a type cast but discard the returned type.
 pattern—or a subclass of that type. If the match succeeds, the type of the matched value is cast to the  pattern.
.
 represents the value of an expression. Expression patterns appear only in  statement case labels.
 operator. The matches succeeds if the . By default, the  operator. It can also match an integer value with a range of integers in an  operator to provide custom expression matching behavior. For example, you can rewrite the above example to compare the  expression with a string representations of points.
Copyright � 2015 Apple Inc. All rights reserved. 
  This chapter describes parameters and arguments for generic types, functions, and initializers. When you declare a generic type, function, or initializer, you specify the type parameters that the generic type, function, or initializer can work with. These type parameters act as placeholders that are replaced by actual concrete type arguments when an instance of a generic type is created or a generic function or initializer is called.
.
 specifies the type parameters of a generic type or function, along with any associated constraints and requirements on those parameters. A generic parameter clause is enclosed in angle brackets (<>) and has one of the following forms:
. A , and so on). You have access to the type parameters (and any of their associated types) in the rest of the type, function, or initializer declaration, including in the signature of the function or initializer.
 specifies that a type parameter inherits from a specific class or conforms to a protocol or protocol composition. For instance, in the generic function below, the generic parameter  protocol.
 protocol, this function accepts arguments of either type. In contrast with generic types, you don't specify a generic argument clause when you use a generic function or initializer. The type arguments are instead inferred from the type of the arguments passed to the function or initializer.
. A .
 clause specify that a type parameter inherits from a class or conforms to a protocol or protocol composition. Although the  and so on), you can use it to provide more complex constraints on type parameters and their associated types. For instance, you can express the constraints that a generic type .

  As mentioned above, you can constrain the associated types of type parameters to conform to protocols. For example, the generic parameter clause ).
 operator. For example, the generic parameter clause  protocol and that their associated types must be identical.

  Any type argument substituted for a type parameter must meet all the constraints and requirements placed on the type parameter.

  You can overload a generic function or initializer by providing different constraints, requirements, or both on the type parameters in the generic parameter clause. When you call an overloaded generic function or initializer, the compiler uses these constraints to resolve which overloaded function or initializer to invoke.
 specifies the type arguments of a generic type. A generic argument clause is enclosed in angle brackets (<>) and has the following form:
 is a comma-separated list of type arguments. A  is the name of an actual concrete type that replaces a corresponding type parameter in the generic parameter clause of a generic type. The result is a specialized version of that generic type. As an example, the Swift standard library defines a generic dictionary type as:
. Each type argument must satisfy all the constraints of the generic parameter it replaces, including any additional requirements specified in a  clause. In the example above, the  protocol.

  You can also replace a type parameter with a type argument that is itself a specialized version of a generic type (provided it satisfies the appropriate constraints and requirements). For example, you can replace the type parameter , to form an array whose elements are themselves arrays of integers.
, you don't use a generic argument clause to specify the type arguments of a generic function or initializer.
Copyright � 2015 Apple Inc. All rights reserved. 